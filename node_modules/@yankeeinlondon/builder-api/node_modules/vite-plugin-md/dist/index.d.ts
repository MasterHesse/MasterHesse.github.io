import { UserConfig, InlineConfig, Plugin } from 'vite';
import MarkdownIt from 'markdown-it';
import { ConfiguredBuilder, BuilderOptions } from '@yankeeinlondon/builder-api';
import { MaybeRef } from '@vueuse/core';
import * as TE from 'fp-ts/lib/TaskEither.js';
import { Either } from 'fp-ts/lib/Either.js';
import { IElement, Fragment } from '@yankeeinlondon/happy-wrapper';
import { ExistingRawSourceMap } from 'rollup';

type FilterPattern = ReadonlyArray<string | RegExp> | string | RegExp | null;

/**
 * **PipelineStage**
 *
 * The _stage_ in the transformation pipeline:
 *
 * - `initialize` - meant for configuration settings
 * - `metaExtracted` - all frontmatter has been separated from the text content
 * giving you a clear but raw markdown content and frontmatter key/value
 * - `parser` - a **markdown-it** parser is initialized; providing the `md` prop
 * on the payload. This is where builders who want to act as a markdown-it-plugin
 * will want to engage.
 * - `parsed` - The **MarkdownIt** parser is initialized and all builders
 * have been able to apply their customizations to it.
 * - `dom` - The HTML has been converted to a HappyDom tree to allow interested builders
 * to manipulate contents using DOM based queries
 * - `sfcBlocksExtracted` - SFC blocks (template, script, and an array of customBlocks)
 * are ready for builders to inspect/mutate/etc.
 * - `closeout` - All mutations of page are complete; builders can hook into this stage
 * but will _not_ be able to mutate at this stage
 */
type PipelineStage = 'initialize' | 'metaExtracted' | 'parser' | 'parsed' | 'dom' | 'sfcBlocksExtracted' | 'closeout';
interface RulesUse {
    ruleName: string;
    usage: 'adds' | 'patches' | 'modifies';
    description?: string;
}
type Parser<S extends PipelineStage> = S extends 'parser' | 'parsed' | 'dom' | 'sfcBlocksExtracted' | 'closeout' ? {
    /** the **MarkdownIT** parser instance */
    parser: MarkdownIt;
} : {};
/**
 * The **Route** custom-block can be configured with these properties.
 *
 * Note: this is best done with the _meta_ builder
 */
interface RouteConfig {
    /** The Route's name */
    name?: string;
    /** The Route's path */
    path?: string;
    /** A dictionary of key/value pairs for the route */
    meta?: Frontmatter;
}
interface LinkProperty {
    rel?: string;
    href?: string;
    integrity?: string;
    crossorigin?: string;
    [key: string]: unknown;
}
interface StyleProperty {
    type?: string;
    [key: string]: unknown;
}
/**
 * The <base> element specifies the base URL and/or target for all
 * relative URLs in a page.
 */
interface BaseProperty {
    href?: string;
    target?: string;
}
interface ScriptProperty {
    /**
     * For classic scripts, if the async attribute is present, then the classic
     * script will be fetched in parallel to parsing and evaluated as soon as it is
     * available.
     *
     * For module scripts, if the async attribute is present then the scripts and
     * all their dependencies will be executed in the defer queue, therefore they will
     * get fetched in parallel to parsing and evaluated as soon as they are available.
     */
    async?: boolean;
    crossorigin?: string;
    /** only to be used alongside the `src` attribute */
    defer?: boolean;
    /** Provides a hint of the relative priority to use when fetching an external script.  */
    fetchPriority?: 'high' | 'low' | 'auto';
    integrity?: string;
    /**
     * This Boolean attribute is set to indicate that the script should not be executed
     * in browsers that support ES2015 modules â€” in effect, this can be used to serve
     * fallback scripts to older browsers that do not support modular JavaScript code.
     */
    nomodule?: boolean;
    nonce?: string;
    referencePolicy?: 'no-referrer' | 'no-referrer-when-downgrade' | 'origin' | 'origin-when-cross-origin' | 'same-origin' | 'strict-origin' | 'strict-origin-when-cross-origin' | 'unsafe-url';
    src?: string;
    type?: string;
    [key: string]: unknown;
}
/**
 * The properties destined for the HEAD block in the HTML
 */
interface HeadProps {
    title?: MaybeRef<string>;
    meta?: MaybeRef<MetaProperty[]>;
    link?: MaybeRef<LinkProperty[]>;
    base?: MaybeRef<BaseProperty[]>;
    style?: MaybeRef<StyleProperty[]>;
    script?: MaybeRef<ScriptProperty[]>;
    htmlAttrs?: MaybeRef<Record<string, unknown>[]>;
    bodyAttrs?: MaybeRef<Record<string, unknown>[]>;
    [key: string]: unknown;
}
/** types available _only_ during initialization */
type Initialization<S extends PipelineStage> = S extends 'initialize' ? {} : {};
interface PipelineUtilityFunctions {
    /**
     * Adds a `<link>` to the page's header section
     */
    addLink: (link: LinkProperty) => void;
    /**
     * Adds a `<script>` reference to the page's header section
     */
    addScriptReference: (script: ScriptProperty) => void;
    /**
     * Allows the addition of code which will be brought into the
     * `<script setup>` block if using VueJS 3.x and into a normal
     * `<script>` block in VueJS2
     */
    addCodeBlock: (name: string, script: string, forVue2?: string[] | undefined) => void;
    /**
     * Adds a `<style>` reference to the page's header section
     */
    addStyleReference: (style: StyleProperty) => void;
    /**
     * Adds meta-properties to the HEAD section of the page
     */
    addMetaProperty: (meta: MetaProperty) => void;
    /**
     * Adds a VueJS `<script>` block to the HTML (which VueJS will eventually place in HEAD). A style block should be named so that downstream consumers
     * can -- potentially -- override or further modify the style.
     */
    addStyleBlock: (name: string, style: IElement | string) => void;
}
type MetaExtracted<S extends PipelineStage> = S extends 'initialize' ? {} : {
    /** the frontmatter metadata */
    frontmatter: Frontmatter;
    /**
     * The markdown content (after extracting frontmatter)
     */
    md: string;
    /**
     * Meta properties that will be put into the HEAD section
     *
     */
    meta: MetaProperty[];
    excerpt?: string;
} & PipelineUtilityFunctions;
type HtmlContent<S extends PipelineStage> = S extends 'parsed' | 'sfcBlocksExtracted' | 'closeout' ? {
    /**
     * the HTML produced from MD content (and using parser rules passed in)
     */
    html: string;
} : S extends 'dom' ? {
    /**
     * the HTML wrapped into a HappyDom fragment
     */
    html: Fragment;
    /**
     * If any code blocks were found on the page then their languages will be represented
     * here as a `Set<string>`
     */
    fencedLanguages: Set<string>;
} : {};
type Blocks<S extends PipelineStage> = S extends 'sfcBlocksExtracted' | 'closeout' ? {
    /** the SFC's template block (aka, html content) */
    templateBlock: string;
    /**
     * The `<script setup ...>` block.
     *
     * Since there can only be one block, if the markdown has multiple <script setup>
     * blocks then the interior code will be moved into the single code block to retain
     * the required cardinality.
     */
    scriptSetup: string;
    /** the traditional <script> blocks found on the page */
    scriptBlocks: string[];
    /** the style blocks found on the page */
    styleBlocks: string[];
    /** any other top-level SFC blocks besides the traditional */
    customBlocks: string[];
} : {};
type Completed<S extends PipelineStage> = S extends 'closeout' ? {
    /** the finalized component in string form */
    component: string;
    /** The sourcemap from Markdown to SFC */
    map?: ExistingRawSourceMap | undefined;
} : {};
type Pipeline<S extends PipelineStage, B extends readonly ConfiguredBuilder<string, BuilderOptions, PipelineStage, string>[] = readonly ConfiguredBuilder<string, BuilderOptions, PipelineStage, string>[]> = {
    stage: S;
    /** the underlying filename of the source */
    fileName: string;
    /** the raw content in the file being processed */
    content: string;
    /** the `vite-plugin-md` options */
    options: ResolvedOptions<B>;
    /** the Vite config */
    viteConfig: UserConfig;
    /**
     * All properties which are destined for the HEAD section of the HTML
     */
    head: HeadProps;
    /**
     * Meta properties associated with a page's route; used
     * and managed with the "meta" builder.
     */
    routeMeta?: RouteConfig;
    frontmatter?: Frontmatter;
    /**
     * Indicates which _languages_ were found on the page; this property typically
     * shouldn't be set but rather is managed by the `code()` builder and provided
     * for contextual decisions.
     */
    codeBlockLanguages: {
        /** the language setting the page author used */
        langsRequested: string[];
        /** the language used to parse with the highlighter */
        langsUsed: string[];
    };
    /**
     * A store for _named_ VueJS `<style>` blocks which will be injected
     * into the SFC component at the appropriate time.
     */
    vueStyleBlocks: Record<string, IElement>;
    /**
     * Provides a _named_ set of code blocks which will be injected into
     * the VueJS's SFC's `<script setup>` section for Vue 3 and in a
     * `<script>` block. All blocks will be setup for Typescript.
     *
     * Note: contributors may optionally include additional trailing lines
     * for Vue2; this will allows you to export variables you've defined.
     */
    vueCodeBlocks: Record<string, string | [base: string, vue2Exports: string[]]>;
} & Parser<S> & MetaExtracted<S> & HtmlContent<S> & Blocks<S> & Completed<S> & Initialization<S>;
/**
 * Carries an Either<T> condition which is either:
 * - a _string_ error condition
 * - a `Pipeline<S>` value
 */
type PipeEither<S extends PipelineStage, B extends readonly GenericBuilder[]> = Either<string, Pipeline<S, B>>;
/**
 * Carries an `TaskEither<T>` condition which is either:
 * - a _string_ error condition
 * - a `() => Promise<Pipeline<S>>` task
 */
type PipeTask<S extends PipelineStage, B extends readonly ConfiguredBuilder<string, {}, PipelineStage, string>[]> = TE.TaskEither<string, Pipeline<S, B>>;
/**
 * A pipeline payload or either an async `PipeTask<S>` or a synchronous `PipeEither<S>`
 */
type PipelinePayload<S extends PipelineStage, B extends readonly GenericBuilder[]> = PipeTask<S, B> | PipeEither<S, B>;
/**
 * A _synchronous_ transformer function which:
 *
 * - receives a payload of `PipeEither<F>`, and
 * - converts it to a type of `PipeEither<T>`
 */
type SyncPipelineTransformer<F extends PipelineStage, T extends PipelineStage, B extends readonly GenericBuilder[]> = (payload: PipeTask<F, B>) => PipeTask<T, B>;
/**
* An _asynchronous_ transformer function which:
*
* - receives a payload of `PipeTask<F>` (async) or `PipeEither<F>` (sync)
* - converts it to a type of `PipeTask<T>`
*/
type AsyncPipelineTransformer<F extends PipelineStage, T extends PipelineStage, B extends readonly GenericBuilder[]> = (payload: PipeTask<F, B>) => PipeTask<T, B>;

type GenericBuilder = ConfiguredBuilder<string, BuilderOptions, PipelineStage, string>;
/**
 * The key/value definition for Route Properties.
 *
 * Note: we know that "layout" is likely and a _string_
 * but all other props are possible.
 */
interface RouteProperties {
    layout?: string;
    requiresAuth?: boolean;
    section?: string;
    [key: string]: unknown;
}
interface SfcBlocks {
    /** the HTML template block of the SFC */
    html: string;
    meta: ProcessedFrontmatter;
    /** the _script_ blocks  */
    script: string;
    /**
     * Any custom blocks which may exist on the page beyond
     * just "script" and "template"
     */
    customBlocks: string[];
    /**
     * After all processing, the component's definition is available as a string
     */
    component: string;
}
/** a `<meta />` property in HTML is defined with the following name/values */
interface MetaProperty {
    key?: string;
    /**
     * the "name" property used by Facebook and other providers who
     * use the Opengraph standards
     */
    property?: string;
    /**
     * used by google to identify the "name" of the name/value pair
     */
    itemprop?: string;
    /**
     * used by Twitter to indicate the "name" field in a meta properties
     * name/value pairing
     */
    name?: string;
    /**
     * The value of the meta property
     */
    content?: any;
    [key: string]: unknown;
}
/**
 * Frontmatter content is represented as key/value dictionary
 */
interface Frontmatter {
    title?: string;
    description?: string;
    subject?: string;
    category?: string;
    name?: string;
    excerpt?: string;
    image?: string;
    layout?: string;
    requiresAuth?: boolean;
    meta?: MetaProperty[];
    [key: string]: unknown;
}
type EnumValues<T extends string | number> = `${T}`;
type Include<T, U, L extends boolean = false> = L extends true ? T extends U ? U extends T ? T : never : never : T extends U ? T : never;
type Retain<T, K extends keyof T> = Pick<T, Include<keyof T, K>>;
interface ExcerptMeta {
    fileName: string;
    frontmatter: Frontmatter;
}
/**
 * A function which receives the full content of the page and
 * gives control to the function to determine what part should
 * be considered the excerpt.
 *
 * Example:
 * ```ts
 * function firstFourLines(content, meta) {
 *    return content
 *      .split('\n')
 *      .slice(0, 4)
 *      .join(' ')
 * }
 * ```
 */
type ExcerptFunction = ((contents: string, meta: ExcerptMeta) => string) | ((contents: string) => string);
/**
 * A callback function to dynamically mutate the frontmatter properties
 * ```ts
 * const cb: FmValueCallback = (fm, filename) => ({
 *    ...fm,
 *    category: filename.includes('blog') ? 'blog' : 'unknown
 * })
 * ```
 */
type FmValueCallback = (fm: Frontmatter, filename: string) => Frontmatter;
/**
 * Values allowed to be set as frontmatter props
 */
type FmAllowedValue = string | number | undefined | any[] | Symbol | boolean;
/**
 * Options for Graymatter parser [[Docs](https://github.com/jonschlinkert/gray-matter#options)]
 */
interface GraymatterOptions {
    excerpt?: boolean | Function;
    /**
     * Define custom engines for parsing and/or stringifying frontmatter.
     *
     * Engines may either be an object with `parse` and (optionally) stringify
     * methods, or a function that will be used for parsing only.
     *
     * **Note:** we offer this because the GrayMatter library does but be sure you
     * know what you're doing if you're changing this as this repo has no test to ensure
     * that modification of this will work here.
     */
    engines?: Record<string, () => any>;
    /**
     * Define the engine to use for parsing front-matter.
     *
     * ```ts
     * { language: 'yaml' }
     * ```
     *
     * **Note:** we offer this because the GrayMatter library does but be sure you
     * know what you're doing if you're changing this as this repo has no test to ensure
     * that modification of this will work here.
     *
     * @default "yaml"
     */
    language?: string;
    /**
     * Open and close delimiters can be passed in as an array of strings.
     *
     * **Note:** we offer this because the GrayMatter library does but be sure you
     * know what you're doing if you're changing this as this repo has no test to ensure
     * that modification of this will work here.
     */
    delimiters?: string | [string, string];
}
interface ProcessedFrontmatter {
    /**
     * non-meta props intended for the HEAD of the page
     */
    head: Record<string, any>;
    /**
     * Meta properties intended for the HEAD of the page
     */
    metaProps: MetaProperty[];
    /**
     * The core metadata that a page contains
     */
    frontmatter: Frontmatter;
    /**
     * a dictionary of key/values to that are intended to be associated with the route's
     * metadata.
     */
    routeMeta: RouteProperties;
}
interface Options<B extends readonly ConfiguredBuilder<string, BuilderOptions, PipelineStage, string>[]> {
    style?: {
        baseStyle?: 'none' | 'github';
    };
    /** allows adding in Builder's which help to expand functionality of this plugin */
    builders?: B;
    /**
     * Explicitly set the Vue version.
     *
     * @default auto detected
     */
    vueVersion?: `2.${string}` | `3.${string}`;
    /**
     * Enable head support.
     *
     * You will need to install @vueuse/head and register to App in `main.js`/`main.ts`.
     *
     * @default false
     */
    headEnabled?: boolean;
    /**
     * The head field in frontmatter used to be used for `@vueuse/head`
     *
     * When an empty string is passed, it will use the root properties of the frontmatter
     *
     * @default ''
     */
    headField?: string;
    /**
     * Parse for frontmatter
     *
     * @default true
     */
    frontmatter?: boolean;
    /**
     * Default values for a frontmatter properties. Property defaults can be static
     * values or be provided at build time by a callback function. In cases where
     * the callback is used, it must conform to the `FrontmatterDefaultValue`
     * type.
     *
     * All values at the page level will override these property values.
     *
     * @default {}
     */
    frontmatterDefaults?: FmValueCallback | Record<string, FmAllowedValue>;
    /**
     * Can _override_ page-level author's frontmatter properties
     */
    frontmatterOverrides?: FmValueCallback | Record<string, FmAllowedValue>;
    /**
     * This property determines how to process "excerpts" within your Markdown files.
     *
     * - a **boolean** true/false simply turns the feature of looking for an excerpt in the body
     * of your page on or off respectively and will use the default separator of "---" when turned on
     *
     * - a **string** value ensures that excerpt parsing is turned on but that the default separator
     * is replaced with whatever you provide.
     *
     * - a **function** gives you a callback to handle this how you see fit. Refer to the `ExcerptFunction`
     * symbol to understand the contract of this callback.
     *
     * **Note**: in all cases, if the frontmatter props are enabled and a user sets the `excerpt` property
     * this will be seen as a "default value" for the excerpt.
     *
     * @default false
     */
    excerpt?: boolean | ExcerptFunction | string;
    /**
     * When using the `excerpt` functionality, this flag determines whether the excerpt text
     * found in the body should be _extracted_ from the body of the document.
     *
     * @default false
     */
    excerptExtract?: boolean;
    /**
     * Expose excerpt via expose API.
     *
     * This is on by default and the feature is primarily used to allow excerpts "on page"
     * but block them being exposed externally as an export. This is clearly an edge case.
     * If you _are_ using excerpts be sure to set the `excerpt` property.
     *
     * @default true
     */
    exposeExcerpt?: boolean;
    /**
     * Remove custom SFC block
     *
     * @default ['i18n']
     */
    customSfcBlocks?: string[];
    /**
     * Custom function to provide defaults to the frontmatter and
     * move certain attributes into the "meta" category.
     *
     * Note: _overriding this will remove built-in functionality setting
     * "meta" properties and the built-in "head" support. Do this only
     * if you know what you're doing._
     *
     * @deprecated all use-cases where overriding this have been removed
     * with the introduction of the Builder API
     */
    frontmatterPreprocess?: (frontmatter: Frontmatter, options: ResolvedOptions<B>) => ProcessedFrontmatter;
    /**
     * Expose frontmatter via expose API
     *
     * @default true
     */
    exposeFrontmatter?: boolean;
    /**
     * Add `v-pre` to `<code>` tag to escape curly brackets interpolation
     *
     * @see https://github.com/antfu/vite-plugin-md/issues/14
     * @default true
     */
    escapeCodeTagInterpolation?: boolean;
    /**
     * Options passed to Markdown It
     *
     * @default { html: true, linkify: true, typographer: true }
     */
    markdownItOptions?: MarkdownIt.Options;
    /**
     * Plugins for Markdown It
     *
     * **Note:** there is no problem using MarkdownIt plugins whatsoever but in many
     * cases you may find that Builder APIs are available that provider greater functionality.
     */
    markdownItUses?: (MarkdownIt.PluginSimple | [MarkdownIt.PluginSimple | MarkdownIt.PluginWithOptions<any>, any] | any)[];
    /**
     * A function providing the Markdown It instance gets the ability to apply custom
     * settings/plugins
     *
     * @deprecated prefer use of Builder API which provides an easy mechanism to wrap
     *
     */
    markdownItSetup?: (MarkdownIt: MarkdownIt) => void;
    /**
     * Options which can be passed to [gray-matter](https://github.com/jonschlinkert/gray-matter)
     *
     * Note: these are a few obscure and advanced settings and should be avoided unless necessary.
     * All core functionality -- some of which the graymatter package provides -- is provided directly
     * the root of this options hash (e.g., `excerpt`, `frontmatter`, etc.)
     */
    grayMatterOptions?: Omit<GraymatterOptions, 'excerpt'>;
    /**
     * Class name for the page's wrapper <div>
     *
     * @default 'markdown-body'
     */
    wrapperClasses?: string | string[];
    /**
     * A component name which the page will be wrapped with (aka,
     * the page becomes HTML and is made a _slot_ for this component)
     *
     * @default undefined
     */
    wrapperComponent?: string | undefined | null;
    /**
     * Custom transformations to apply _before_ and/or _after_ the markdown transformation
     *
     * Note: these transforms provide _raw_ inputs which means that "code" represents
     * markdown content along with possibly frontmatter (in the before state) and all of
     * of the SFC blocks (e.g., template, script, custom) in string format.
     *
     * @deprecated these transforms are available using the Builder API -- as well as many more --
     * and this is the preferred means of mutating the transformation pipeline.
     */
    transforms?: {
        before?: (code: string, id: string) => string;
        after?: (code: string, id: string) => string;
    };
    /**
     * Optionally allows user to explicitly whitelist files which will be transformed
     * from markdown to VueJS components. By default all files with `.md` extension
     * are included.
     */
    include?: FilterPattern;
    /**
     * Allows user to add a blacklist filter to exclude transforming some of the markdown
     * files to VueJS components.
     */
    exclude?: FilterPattern;
}
interface ResolvedOptions<B extends readonly ConfiguredBuilder<string, BuilderOptions, PipelineStage, string>[] = []> extends Required<Options<B>> {
    wrapperClasses: string;
    frontmatterDefaults: FmValueCallback | Record<string, FmAllowedValue>;
    frontmatterOverrides: FmValueCallback | Record<string, FmAllowedValue>;
    /**
     * a utility which tests whether a given builder is being used
     */
    usingBuilder: (name: string) => boolean;
}
interface ViteConfigPassthrough {
    mode: UserConfig['mode'];
    base: UserConfig['base'];
    [key: string]: unknown;
}
type WithConfig<T extends ResolvedOptions<any>> = ViteConfigPassthrough & T;
type ReturnValues = string | string[] | number | boolean | Object;

/**
 * Composes the `template` and `script` blocks, along with any other `customBlocks` from
 * the raw markdown content along with user options.
 */
declare function composeSfcBlocks<B extends readonly GenericBuilder[] = []>(id: string, raw: string, opts?: Options<B>, config?: Partial<ViteConfigPassthrough>): Promise<Pipeline<"closeout", B>>;

type ViteConfig = Readonly<Omit<UserConfig, 'plugins' | 'assetsInclude' | 'optimizeDeps' | 'worker'> & {
    configFile: string | undefined;
    configFileDependencies: string[];
    inlineConfig: InlineConfig;
    experimental: any;
}>;
declare function VitePluginMarkdown<O extends Options<any>>(userOptions?: O): Plugin;

export { AsyncPipelineTransformer, BaseProperty, Blocks, Completed, EnumValues, ExcerptFunction, ExcerptMeta, FmAllowedValue, FmValueCallback, Frontmatter, GenericBuilder, GraymatterOptions, HeadProps, HtmlContent, Include, Initialization, LinkProperty, MetaExtracted, MetaProperty, Options, Parser, PipeEither, PipeTask, Pipeline, PipelinePayload, PipelineStage, PipelineUtilityFunctions, ProcessedFrontmatter, ResolvedOptions, Retain, ReturnValues, RouteConfig, RouteProperties, RulesUse, ScriptProperty, SfcBlocks, StyleProperty, SyncPipelineTransformer, ViteConfig, ViteConfigPassthrough, WithConfig, composeSfcBlocks, VitePluginMarkdown as default };
