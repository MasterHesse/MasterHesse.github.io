import * as happy_dom from 'happy-dom';
import { Document as Document$1, DocumentFragment as DocumentFragment$1, IElement as IElement$1, IComment as IComment$1, IText as IText$1, INode as INode$1 } from 'happy-dom';
import { Events } from 'vue';

/**
 * Use the self-reported numeric type that a node presents
 * to identify what type it is.
 */
declare const nodeTypeLookup: (type: number) => NodeType | undefined;
/**
 * Determines the "content-type" of a given node
 */
declare const getNodeType: (node: Container | HTML) => NodeType;
/**
 * A helper utility to help convert DOM nodes or HTML to common type.
 *
 * Start by providing the _exclusions_ you want to make for input. By default, all
 * `Container` types are allowed along with `HTML`
 */
declare const solveForNodeType: NodeSolver;
/**
 * Ensures any Container, array of Containers, or even HTML or HTML[] are all
 * normalized down to just HTML.
 */
declare function toHtml<D extends ContainerOrHtml | ContainerOrHtml[] | null>(node: D): HTML;
/**
 * Clones most DOM types
 */
declare function clone<T extends Container | HTML>(container: T): T;
/**
 * ensures that a given string doesn't have any HTML inside of it
 */
declare function safeString(str: string): string;

type InspectionTuple = [msg: string, item: unknown];
type HTML = string;
type GetAttribute<T extends string> = <N extends Container | HTML>(node: N) => string;
type NodeTypeInput<T extends ReturnType<typeof getNodeType>> = T extends "html" ? string : T extends "text" ? IText : T extends "element" ? IElement : T extends "document" ? HappyDoc : T;
/** The distinct types of Nodes we may encounter */
type NodeType = "html" | "text" | "element" | "comment" | "node" | "document" | "fragment";
type NodeSolverInput<T extends NodeType> = T extends "html" ? HTML : T extends "comment" ? IComment : T extends "text" ? IText : T extends "element" ? IElement : T extends "node" ? INode : T extends "document" ? HappyDoc : T extends "fragment" ? Fragment : unknown;
type DocRoot = HappyDoc | Fragment;
type DomNode = IElement | IText | IComment | INode;
type Container = DocRoot | DomNode;
type ContainerOrHtml = Container | HTML;
/**
 * The select.update/updateAll methods not only receive the _element_
 * which is being mutated but also the _index_ and _total count_ of selection
 * results.
 */
type UpdateSignature = [el: IElement, idx: number, total: number] | [el: IElement, idx: number] | [el: IElement];
interface ToHtmlOptions {
    pretty?: boolean;
    indent?: number;
}
interface TreeSummary {
    node: string;
    children: TreeSummary[];
}
interface Tree {
    node: Container;
    type: string;
    level: number;
    summary: () => TreeSummary;
    toString: () => string;
    children: Tree[];
}
/**
 * A callback which receives a node type `C` and allows side-effects and/or
 * mutation. It expects the same container structure -- mutation or not -- to
 * be passed back as a return value. The one exception is that if you pass back
 * a `false` value then the element will be removed.
 */
type UpdateCallback_Native = (el: IElement, idx: number, total: number) => IElement | false;
type UpdateCallback = (el: IElement, idx: number, total: number) => IElement | false;
type MapCallback<I, O> = (input: I) => O;
interface NodeSolverDict<O> {
    html: (input: HTML) => O extends "mirror" ? HTML : O;
    text: (input: IText) => O extends "mirror" ? IText : O;
    element: (input: IElement, parent?: IElement | DocRoot) => O extends "mirror" ? IElement : O;
    comment: (input: IComment) => O extends "mirror" ? IComment : O;
    node: (input: INode) => O extends "mirror" ? INode : O;
    document: (input: HappyDoc) => O extends "mirror" ? HappyDoc : O;
    fragment: (input: Fragment) => O extends "mirror" ? Fragment : O;
}
/**
 * A fully configured solver which is ready to convert a node into type `O`; if `O` is never
 * then it will mirror the input type as the output type
 */
type NodeSolverReady<E extends NodeType, O> = <N extends Exclude<Container | HTML | null, E>>(node: N, parent?: IElement | DocRoot) => O extends "mirror" ? N : O;
interface NodeSolverReceiver<E extends NodeType, O> {
    /** provide a solver dictionary */
    solver: (solver: Omit<NodeSolverDict<O>, E>) => NodeSolverReady<E, O>;
}
interface NodeSolverWithExclusions<E extends NodeType> {
    /** provide a type which all solvers will convert to */
    outputType: <O>() => NodeSolverReceiver<E, O>;
    /** the input type should be maintained as the output type */
    mirror: () => NodeSolverReceiver<E, "mirror">;
}
/**
 * Allows you to setup a type-string utility which receives DOM containers
 * and returns either the same container type or a specific type.
 *
 * This uses a builder API, of which this is the first step.
 */
type NodeSolver = <E extends NodeType = never>(...exclude: E[]) => NodeSolverWithExclusions<E>;
/**
 * A selector API provided by using the `select()` utility
 */
interface NodeSelector<T extends Container | "html"> {
    /**
     * The _type_ of the root node
     */
    type: () => NodeType;
    /**
     * Find the first `IElement` found using the selector string.
     *
     * Note: _by default the return type includes `null` if no results were found but if you
     * prefer to throw an error you can state the error text and an error will be thrown_
     */
    findFirst: <E extends string | undefined>(sel: string, errorMsg?: E) => undefined extends E ? IElement | null : IElement;
    /**
     * Find _all_ `IElement` results returned from the Selection query
     */
    findAll: <S extends string | undefined>(sel: S) => IElement[];
    /**
     * Appends one or more elements to the root selected node
     */
    append: (content?: (IText | IElement | HTML | undefined) | (IText | IElement | HTML | undefined)[]) => NodeSelector<T>;
    /**
     * Allows the injection of a callback which will be used to mutate on the first `IElement` node
     * which matches the first
     */
    update: <E extends string | boolean>(sel?: string, errorMsg?: E) => <CB extends UpdateCallback>(cb: CB) => NodeSelector<T>;
    /**
     * Provides a way to inject an update callback which will be applied to all IElement nodes
     * which meet the selector query. If no query is provided, then this will be all `IElement`
     * children of the root node.
     */
    updateAll: <S extends string | undefined>(sel?: S) => <CB extends UpdateCallback>(cb: CB) => NodeSelector<T>;
    /**
     * Map over all selected items and transform them as needed; results are returned to
     * caller (exiting the selection API) and operation does not mutate the parent
     * selected DOM tree.
     */
    mapAll: <S extends string | undefined>(selection?: S) => <O>(mutate: MapCallback<IElement, O>) => O[];
    /**
     * Filters out all nodes which match the DOM query selector and returns the
     * selector API
     */
    filterAll: <S extends string>(selection: S) => NodeSelector<T>;
    /**
     * Wraps the current _selection_ with an Element or Fragment.
     *
     * You may optionally add a prefix to the error message thrown if the
     * wrapper does not represent a valid block/wrapper element.
     */
    wrap: <C extends IElement | string>(wrapper: C, errMsg?: string) => NodeSelector<T>;
    /**
     * Returns the root node with all mutations included
     */
    toContainer: () => undefined extends T ? Fragment : T extends "html" ? string : T;
}

type SetAttribute<T extends string> = (value: string) => <N extends Container | HTML>(node: N) => N;
type SetAttributeTo<_T extends string, _V extends string> = <N extends Container | HTML>(node: N) => N;
declare const setAttribute: <T extends string>(attr: T) => SetAttribute<T>;
declare const getAttribute: <T extends string>(attr: T) => GetAttribute<T>;
/**
 * Provides the classes defined on a given container's top level
 * element as an array of strings
 */
declare const getClassList: (container: Container | HTML | null) => string[];
type RemoveClass<R extends string | string[]> = <C extends DocRoot | IElement | HTML>(container: C) => C;
/**
 * Removes a class from the top level node of a container's body.
 *
 * Note: if the class wasn't present then no change is performed
 */
declare const removeClass: <R extends string | string[]>(remove: R) => RemoveClass<R>;
type AddClass<A extends string[] | string[][]> = <C extends DocRoot | IElement | HTML>(container: C) => C;
/**
 * Adds a class to the top level node of a document's body.
 */
declare const addClass: <A extends string[] | string[][]>(...add: A) => AddClass<A>;
declare const addVueEvent: (event: keyof Events, value: string) => <T extends string | happy_dom.IElement>(el: T) => T;
type Filter = string | RegExp;
type FilterCallback = (removed: string[]) => void;
type FiltersWithCallback = [FilterCallback, ...Filter[]];
/**
 * Filters classes out from a given element using _filters_, where a filter:
 *
 * - string - when a string it will compare for a direct match
 * - RegExp - will run the RegExp's `test(class)` method
 *
 * Optionally you may pass in a callback function as the first parameter in the
 * the list and this callback will be then called with all filtered properties
 * passed to it. This is useful for creating desirable side-effects like _moving_
 * the classes to some other DOM element (for instance).
 */
declare const filterClasses: <A extends Filter[] | [FilterCallback, ...Filter[]]>(...args: A) => <D extends string | happy_dom.IElement | DocRoot>(doc: D) => D;
/**
 * Checks whether a given node has a parent reference
 */
declare const hasParentElement: (node: ContainerOrHtml) => boolean;
/**
 * Get's the parent element of a given node or returns `null` if not
 * present.
 */
declare const getParent: (node: ContainerOrHtml) => happy_dom.IElement | null;

/**
 * Converts an HTML string into a Happy DOM document tree
 */
declare function createDocument(body: string, head?: string): HappyDoc;
type FragmentFrom<_T extends Container | "html"> = Fragment;
declare function createFragment<C extends Container | HTML>(content?: C): FragmentFrom<C extends string ? "html" : Fragment>;
/**
 * Creates a DOM Node which will be either an `IElement` or `IText` node
 * based on the content passed in.
 */
declare const createNode: (node: Container | string) => IElement | IText;
/**
 * Creates a IText Node
 */
declare function createTextNode(text?: string): IText;
declare function createCommentNode(comment?: string): IComment;
/**
 * Creates an element node and can preserve parent relationship if known
 */
declare const createElement: (el: Container | HTML, parent?: IElement) => IElement;
interface CssVariable {
    prop: string;
    value: string | number | boolean;
}
type ClassDefn = Record<string, string | boolean | number>;
type MultiClassDefn = [selector: string, keyValues: ClassDefn][];
interface ClassApi {
    /** add a child selector */
    addChild: (selector: string, defn: ClassDefn) => ClassApi;
    /** add CSS prop/values */
    addProps: (defn: ClassDefn) => ClassApi;
}
interface InlineStyle {
    /** add a single CSS variable (at a time); the CSS scope will ':root' unless specified */
    addCssVariable: (prop: string, value: string | number | boolean, scope?: string) => InlineStyle;
    addClassDefinition: (selection: string, cb: (api: ClassApi) => void) => InlineStyle;
    addCssVariables: (dictionary: Record<string, string>, scope?: string) => InlineStyle;
    convertToVueStyleBlock: (lang: "css" | "scss", scoped: boolean) => InlineStyle;
    finish: () => IElement;
}
/**
 * Creates a new `<style>...</style>` node and provides a simple API surface to allow
 * populating the contents with inline CSS content
 */
declare const createInlineStyle: <T extends string = "text/css">(type?: T) => InlineStyle;

declare const describeNode: (node: Container | HTML | null | UpdateSignature | any[]) => string;
declare const inspect: <T extends boolean>(item?: unknown, toJSON?: T) => false extends T ? Record<string, any> : string;
declare const tree: (node: Container | HTML) => Tree;
/**
 * Allows various content-types to be wrapped into a single
 * Fragment which contains each element as a sibling
 */
declare const siblings: <C extends UpdateSignature | ContainerOrHtml[]>(...content: C) => [...C] extends infer T ? T extends [...C] ? T extends UpdateSignature ? false | happy_dom.IElement : happy_dom.DocumentFragment : never : never;

interface StackLine {
    fn: string | undefined;
    line: number | undefined;
    file: string | undefined;
}
declare class HappyMishap extends Error {
    name: string;
    readonly kind: "HappyWrapper";
    trace: string[];
    readonly line: number | null;
    readonly fn: string;
    readonly file: string;
    readonly structuredStack: StackLine[];
    toJSON(): {
        name: string;
        message: string;
    };
    toString(): {
        name: string;
        message: string;
    };
    constructor(message: string, options?: {
        error?: unknown;
        inspect?: unknown;
        name?: string;
    });
}

/**
 * converts a IHTMLCollection or a INodeList to an array
 */
declare const getChildren: (el: Container) => (IElement | IText)[];
declare const getChildElements: (el: Container) => IElement[];
/**
 * Extracts a node from a DOM tree; is designed to be used with `update/updateAll()`
 * and the `updateChildren()` utilities. It can remove a set of elements as well as retain the extracted elements in
 * an array of nodes.
 * ```
 * const memory = []
 * domTree = select(domTree)
 *  .updateAll('.bad-juju')(extract(memory))
 *  .toContainer()
 * ```
 */
declare const extract: <M extends happy_dom.IElement | happy_dom.IText | undefined>(memory?: M[] | undefined) => <T extends happy_dom.IElement extends M ? happy_dom.IElement : happy_dom.IElement | happy_dom.IText>(node: T) => false;
/**
 * **placeholder**
 *
 * Very similar to the `extract()` utility where it allows certain elements to be
 * removed from the DOM tree and stored in a separate variable but in this case
 * rather then leaving _nothing_ in it's place we can instead leave a _placeholder_ node.
 *
 * If you want to define what this placeholder node should look like you may --
 * by setting the optional `placeholder` element -- but by default you will get:
 *
 * ```html
 * <placeholder></placeholder>
 * ```
 *
 * But all classes on removed element will be retained.
 */
declare const placeholder: <M extends happy_dom.IElement | happy_dom.IText | undefined>(memory?: M[] | undefined, placeholder?: IElement) => <T extends happy_dom.IElement>(node: T) => IElement;
/**
 * Replaces an existing element with a brand new one while preserving the element's
 * relationship to the parent node (if one exists).
 */
declare const replaceElement: (newElement: IElement | HTML) => (oldElement: IElement) => IElement;
/**
 * Appends one or more nodes to a parent container
 */
declare const append: <N extends ContainerOrHtml[]>(...nodes: N | N[]) => <P extends UpdateSignature | ContainerOrHtml>(parent: P) => P extends any[] ? happy_dom.IElement : P;
/**
 * A _partially applied_ instance of the `into()` utility; currently waiting
 * for child/children nodes.
 *
 * Note: the return type of this function is the Parent node (in whatever)
 * container type was passed in. However, child element(s) being wrapped which
 * had reference to a parent node, will have their parent node updated to
 * point now to the new parent node instead. This is important for proper
 * mutation when using the update/updateAll() utilities.
 */
type IntoChildren<P extends DocRoot | IElement | HTML | undefined> = <A extends UpdateSignature | ContainerOrHtml[] | ContainerOrHtml[][]>(...args: A) => A extends UpdateSignature ? IElement | false : undefined extends P ? Fragment : P;
/**
 * A higher order function which starts by receiving a _wrapper_ component
 * and then is fully applied when the child nodes are passed in.
 *
 * This is the _inverse_ of the **wrap()** utility.
 *
 * ```ts
 * const sandwich = into(bread)(peanut, butter, jelly)
 * ```
 */
declare const into: <P extends string | happy_dom.IElement | DocRoot | undefined>(parent?: P | undefined) => IntoChildren<P>;
type ChangeTagNameTo<T extends string> = <E extends [IElement | HTML | HappyDoc | Fragment] | UpdateSignature>(...el: E) => E extends UpdateSignature ? IElement : E;
/**
 * Changes the tag name for the top level container element passed in
 * while preserving the parent node relationship.
 * ```ts
 * // <div>hi</div>
 * const html = changeTagName('div')(`<span>hi</span`)
 * ```
 */
declare const changeTagName: <T extends string>(tagName: T) => ChangeTagNameTo<T>;
/**
 * Prepends an `IElement` as the first child element of a host element.
 *
 * Note: you can use a string representation of an element
 * ```ts
 * const startWith = prepend('<h1>just do it</h1>')
 * const message: IElement = startWith(body)
 * ```
 */
declare const prepend: (prepend: IElement | IText | HTML) => (el: IElement) => IElement;
type Before<_T extends ContainerOrHtml> = <A extends [IElement | HTML | HappyDoc | Fragment] | UpdateSignature>(...afterNode: A) => A extends UpdateSignature ? IElement : A extends string ? string : A;
/**
 * Inserts a set of Node or string objects in the children list of this Element's
 * parent, just before this Element. String objects are inserted as equivalent Text nodes.
 *
 * Note: you can use a string representation of an element
 * ```ts
 * const startWith = before('<h1>just do it</h1>')
 * const message: IElement = startWith(body)
 * ```
 */
declare const before: <B extends ContainerOrHtml>(beforeNode: B) => Before<B>;
declare const after: (afterNode: IElement | IText | HTML) => <B extends string | happy_dom.DocumentFragment | happy_dom.IElement>(beforeNode: B) => B;
/**
 * A payload which is a partial application of the `wrap()` method and expects
 * to no w receive the parent element.
 */
type ReadyForWrapper<_C extends UpdateSignature | ContainerOrHtml[]> = <P extends DocRoot | IElement | HTML | undefined>(parent: P) => undefined extends P ? Fragment : P;
/**
 * **wrap**
 *
 * A higher order function which receives child elements which will need
 * to be wrapped and then fully applied when it receives the singular _wrapper_
 * container.
 *
 * This is the _inverse_ of the **into()** utility.
 *
 * ```ts
 * const sandwich = wrap(peanut, butter, jelly)(bread)
 * ```
 */
declare const wrap: <C extends UpdateSignature | ContainerOrHtml[]>(...children: C) => ReadyForWrapper<C>;

/**
 * Allows the _selection_ of HTML or a container type which is
 * then wrapped and a helpful query and mutation API is provided
 * to work with this DOM element.
 */
declare const select: <D extends string | HappyDoc | happy_dom.DocumentFragment | happy_dom.IElement>(node: D) => NodeSelector<undefined extends D ? happy_dom.DocumentFragment : D extends string ? "html" : D>;

declare function isHappyWrapperError(err: unknown): err is HappyMishap;
declare const isInspectionTuple: (thing: unknown) => thing is InspectionTuple;
declare function isDocument(dom: unknown): dom is HappyDoc;
declare function isFragment(dom: unknown): dom is Fragment;
declare const nodeStartsWithElement: <D extends DocRoot>(node: D) => boolean;
declare const nodeEndsWithElement: <D extends DocRoot>(node: D) => boolean;
declare const nodeBoundedByElements: <D extends DocRoot>(node: D) => boolean;
/**
 * tests whether a given node has a singular Element as a child
 * of the given node
 */
declare const hasSingularElement: <N extends DocRoot>(node: N) => boolean;
declare function isElement(el: unknown): el is IElement;
/**
 * determines if a Doc/DocFragment is a wrapper for only a singular
 * `IElement` node
 */
declare const isElementLike: (container: unknown) => boolean;
/**
 * Tests whether a doc type is wrapping only a text node
 */
declare function isTextNodeLike(node: unknown): boolean;
/**
 * Type guard which detects that the incoming calling signature matches
 * that of the `select()` utilities update/updateAll operation.
 */
declare const isUpdateSignature: (args: unknown) => args is UpdateSignature;
declare function isTextNode(node: unknown): node is IText;
declare const isContainer: (thing: unknown) => thing is Container;
/**
 * detects whether _all_ children of a give node are Elements
 */
declare const nodeChildrenAllElements: <D extends DocRoot>(node: D) => boolean;

/**
 * A DOM document originated from Happy DOM and renamed from
 * `Document` so as to avoid possible conflicts with Typescript's
 * built in `Document` type.
 */
interface HappyDoc extends Document$1 {
}
type Document = Document$1;
type DocumentFragment = DocumentFragment$1;
type Fragment = DocumentFragment$1;
/** An element in the DOM [happy-dom] */
type IElement = IElement$1;
type IComment = IComment$1;
type IText = IText$1;
type INode = INode$1;

export { AddClass, Before, ChangeTagNameTo, ClassApi, ClassDefn, Container, ContainerOrHtml, CssVariable, DocRoot, Document, DocumentFragment, DomNode, Filter, FilterCallback, FiltersWithCallback, Fragment, FragmentFrom, GetAttribute, HTML, HappyDoc, HappyMishap, IComment, IElement, INode, IText, InlineStyle, InspectionTuple, IntoChildren, MapCallback, MultiClassDefn, NodeSelector, NodeSolver, NodeSolverDict, NodeSolverInput, NodeSolverReady, NodeSolverReceiver, NodeSolverWithExclusions, NodeType, NodeTypeInput, ReadyForWrapper, RemoveClass, SetAttribute, SetAttributeTo, StackLine, ToHtmlOptions, Tree, TreeSummary, UpdateCallback, UpdateCallback_Native, UpdateSignature, addClass, addVueEvent, after, append, before, changeTagName, clone, createCommentNode, createDocument, createElement, createFragment, createInlineStyle, createNode, createTextNode, describeNode, extract, filterClasses, getAttribute, getChildElements, getChildren, getClassList, getNodeType, getParent, hasParentElement, hasSingularElement, inspect, into, isContainer, isDocument, isElement, isElementLike, isFragment, isHappyWrapperError, isInspectionTuple, isTextNode, isTextNodeLike, isUpdateSignature, nodeBoundedByElements, nodeChildrenAllElements, nodeEndsWithElement, nodeStartsWithElement, nodeTypeLookup, placeholder, prepend, removeClass, replaceElement, safeString, select, setAttribute, siblings, solveForNodeType, toHtml, tree, wrap };
