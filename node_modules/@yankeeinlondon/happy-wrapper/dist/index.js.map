{"version":3,"sources":["../src/attributes.ts","../src/create.ts","../src/errors.ts","../node_modules/.pnpm/callsites@4.0.0/node_modules/callsites/index.js","../src/diagnostics.ts","../src/nodes.ts","../src/type-guards.ts","../src/utils.ts","../src/select.ts"],"sourcesContent":["/* eslint-disable unicorn/consistent-function-scoping */\nimport { pipe } from \"fp-ts/lib/function.js\";\nimport type { IElement } from \"./index\";\nimport type { Events } from \"vue\";\nimport type { INode } from \"happy-dom\";\nimport type {\n  Container,\n  ContainerOrHtml,\n  DocRoot,\n  GetAttribute,\n  HTML,\n} from \"./happy-types\";\nimport { createElement, createFragment, createNode } from \"./create\";\nimport { HappyMishap } from \"./errors\";\nimport { isDocument, isElement, isFragment } from \"./type-guards\";\nimport { getNodeType, solveForNodeType, toHtml } from \"./utils\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type SetAttribute<T extends string> = (\n  value: string\n) => <N extends Container | HTML>(node: N) => N;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type SetAttributeTo<_T extends string, _V extends string> = <\n  N extends Container | HTML\n>(\n  node: N\n) => N;\n\nexport const setAttribute =\n  <T extends string>(attr: T): SetAttribute<T> =>\n  <V extends string>(value: V): SetAttributeTo<T, V> =>\n  <N extends Container | HTML>(node: N): N => {\n    const invalidNode = (n: INode) => {\n      throw new HappyMishap(\n        `You can not use the setAttribute() utility on a node of type: \"${getNodeType(\n          n\n        )}\"`,\n        { name: `setAttribute(${attr})(${value})(INVALID)` }\n      );\n    };\n    const result = solveForNodeType()\n      .mirror()\n      .solver({\n        html: (h) =>\n          pipe(h, createFragment, (f) => setAttribute(attr)(value)(f), toHtml),\n        text: (t) => invalidNode(t),\n        comment: (t) => invalidNode(t),\n        node: (n) => invalidNode(n),\n        fragment: (f) => {\n          f.firstElementChild.setAttribute(attr, value);\n          return f;\n        },\n        document: (d) => {\n          d.body.firstElementChild.setAttribute(attr, value);\n          return d;\n        },\n        element: (e) => {\n          e.setAttribute(attr, value);\n          return e;\n        },\n      })(node);\n\n    return result;\n  };\n\nexport const getAttribute = <T extends string>(attr: T): GetAttribute<T> => {\n  return solveForNodeType(\"text\", \"node\", \"comment\")\n    .outputType<string>()\n    .solver({\n      html: (h) => pipe(h, createFragment, getAttribute(attr)),\n      fragment: (f) => f.firstElementChild.getAttribute(attr),\n      document: (doc) => doc.body.firstElementChild.getAttribute(attr),\n      element: (el) => el.getAttribute(attr),\n    });\n};\n\nconst getClass = getAttribute(\"class\");\nconst setClass = setAttribute(\"class\");\n/**\n * Provides the classes defined on a given container's top level\n * element as an array of strings\n */\nexport const getClassList = (container: Container | HTML | null): string[] => {\n  if (!container) {\n    return [];\n  }\n\n  return solveForNodeType()\n    .outputType<string[]>()\n    .solver({\n      html: (h) => pipe(h, createFragment, getClassList),\n      document: (d) => getClass(d.body.firstElementChild)?.split(/\\s+/) || [],\n      fragment: (f) => getClass(f.firstElementChild)?.split(/\\s+/) || [],\n      element: (e) => getClass(e)?.split(/\\s+/) || [],\n      text: (n) => {\n        throw new HappyMishap(\"Passed in a text node to getClassList!\", {\n          name: \"getClassList\",\n          inspect: n,\n        });\n      },\n      comment: (n) => {\n        throw new HappyMishap(\"Passed in a comment node to getClassList!\", {\n          name: \"getClassList\",\n          inspect: n,\n        });\n      },\n      node: (n) => {\n        throw new HappyMishap(\n          \"Passed in an unknown node type to getClassList!\",\n          { name: \"getClassList\", inspect: n }\n        );\n      },\n    })(container)\n    .filter(Boolean);\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type RemoveClass<R extends string | string[]> = <\n  C extends DocRoot | IElement | HTML\n>(\n  container: C\n) => C;\n\n/**\n * Removes a class from the top level node of a container's body.\n *\n * Note: if the class wasn't present then no change is performed\n */\nexport const removeClass =\n  <R extends string | string[]>(remove: R): RemoveClass<R> =>\n  <D extends DocRoot | IElement | HTML>(doc: D): D => {\n    const current = getClass(doc)?.split(/\\s+/g) || [];\n    const toRemove: string[] = Array.isArray(remove) ? remove : [remove];\n\n    const resultantClassString = [\n      ...new Set<string>(current.filter((c) => !toRemove.includes(c))),\n    ]\n      .filter(Boolean)\n      .join(\" \");\n\n    return setClass(resultantClassString)(doc);\n  };\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type AddClass<A extends string[] | string[][]> = <\n  C extends DocRoot | IElement | HTML\n>(\n  container: C\n) => C;\n\n/**\n * Adds a class to the top level node of a document's body.\n */\nexport const addClass =\n  <A extends string[] | string[][]>(...add: A): AddClass<A> =>\n  <D extends DocRoot | IElement | HTML>(doc: D): D => {\n    const toAdd = (Array.isArray(add) ? add.flat() : [add]) as string[];\n\n    const currentClasses = getClass(doc)?.split(/\\s+/g) || [];\n    const resultantClasses = [\n      ...new Set<string>([...currentClasses, ...toAdd]),\n    ];\n\n    return setClass(resultantClasses.join(\" \").trim())(doc) as D;\n  };\n\nexport const addVueEvent = (event: keyof Events, value: string) => {\n  return <T extends IElement | HTML>(el: T): T => {\n    const isHtml = typeof el === \"string\";\n    const bound = getAttribute(\"v-bind\")(isHtml ? createElement(el) : el);\n    const bind = bound\n      ? bound.replace(\"}\", `, ${event}: '${value}' }`)\n      : `{ ${event}: \"${value}\" }`;\n    const e2 = setAttribute(\"v-bind\")(bind)(el);\n\n    return (isHtml ? toHtml(e2) : el) as T;\n  };\n};\n\nexport type Filter = string | RegExp;\nexport type FilterCallback = (removed: string[]) => void;\nexport type FiltersWithCallback = [FilterCallback, ...Filter[]];\n\nfunction hasFilterCallback(\n  filters: Filter[] | FiltersWithCallback\n): filters is FiltersWithCallback {\n  return typeof filters[0] === \"function\";\n}\n\n/**\n * Filters classes out from a given element using _filters_, where a filter:\n *\n * - string - when a string it will compare for a direct match\n * - RegExp - will run the RegExp's `test(class)` method\n *\n * Optionally you may pass in a callback function as the first parameter in the\n * the list and this callback will be then called with all filtered properties\n * passed to it. This is useful for creating desirable side-effects like _moving_\n * the classes to some other DOM element (for instance).\n */\nexport const filterClasses =\n  <A extends Filter[] | [FilterCallback, ...Filter[]]>(...args: A) =>\n  <D extends DocRoot | IElement | HTML>(doc: D): D => {\n    const el =\n      isDocument(doc) || isFragment(doc)\n        ? (doc.firstElementChild as IElement)\n        : isElement(doc)\n        ? (doc as IElement)\n        : null;\n    if (!el) {\n      throw new HappyMishap(\n        \"An invalid container was passed into filterClasses()!\",\n        { name: \"filterClasses\", inspect: doc }\n      );\n    }\n\n    const filters = hasFilterCallback(args)\n      ? (args.slice(1) as Filter[])\n      : (args as Filter[]);\n    const cb = hasFilterCallback(args) ? args[0] : undefined;\n    const classes = getClassList(el);\n    const removed: string[] = [];\n\n    for (const klass of classes) {\n      const matched = !filters.every((f) =>\n        typeof f === \"string\" ? f.trim() !== klass.trim() : !f.test(klass)\n      );\n      if (matched) {\n        removed.push(klass);\n      }\n    }\n\n    setClass(classes.filter((k) => !removed.includes(k)).join(\" \"))(doc);\n\n    if (cb) {\n      cb(removed);\n    }\n\n    return doc;\n  };\n\n/**\n * Checks whether a given node has a parent reference\n */\nexport const hasParentElement = (node: ContainerOrHtml) => {\n  const n = typeof node === \"string\" ? createNode(node) : node;\n  return solveForNodeType()\n    .outputType<boolean>()\n    .solver({\n      html: () => false,\n      text: (t) => !!t.parentElement,\n      comment: (t) => !!t.parentElement,\n      element: (e) => !!e.parentElement,\n      fragment: (f) => !!f.parentElement,\n      document: () => true,\n      node: (n) => !!n.parentElement,\n    })(n);\n};\n\n/**\n * Get's the parent element of a given node or returns `null` if not\n * present.\n */\nexport const getParent = (node: ContainerOrHtml) => {\n  return hasParentElement(node) ? (node as Container).parentElement : null;\n};\n","/* eslint-disable unicorn/consistent-function-scoping */\nimport { identity } from \"fp-ts/lib/function.js\";\nimport { Comment, Text, Window } from \"happy-dom\";\nimport { dasherize } from \"native-dash\";\nimport { HappyMishap } from \"./errors\";\nimport type { Container, HTML } from \"./happy-types\";\nimport type { HappyDoc, Fragment, IComment, IElement, IText } from \"./index\";\nimport { isElement, isElementLike, isTextNodeLike } from \"./type-guards\";\nimport { clone, solveForNodeType, toHtml } from \"./utils\";\n\n/**\n * Converts an HTML string into a Happy DOM document tree\n */\nexport function createDocument(body: string, head?: string): HappyDoc {\n  const window = new Window();\n  const document = window.document;\n  document.body.innerHTML = body;\n  if (head) {\n    document.head.innerHTML = head;\n  }\n  return document as HappyDoc;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type FragmentFrom<_T extends Container | \"html\"> = Fragment;\n\nexport function createFragment<C extends Container | HTML>(\n  content?: C\n): FragmentFrom<C extends string ? \"html\" : Fragment> {\n  const window = new Window();\n  const document = window.document as HappyDoc;\n  const fragment = document.createDocumentFragment() as Fragment;\n  if (content) {\n    fragment.append(clone(content));\n  }\n\n  return fragment as FragmentFrom<C extends string ? \"html\" : Fragment>;\n}\n\n/**\n * Creates a DOM Node which will be either an `IElement` or `IText` node\n * based on the content passed in.\n */\nexport const createNode = (node: Container | string): IElement | IText => {\n  const frag = createFragment(node);\n  if (isElementLike(frag)) {\n    return frag.firstElementChild as IElement;\n  } else if (isTextNodeLike(frag)) {\n    return frag.firstChild as IText;\n  } else {\n    throw new HappyMishap(\n      \"call to createNode() couldn't be converted to IElement or IText node\",\n      { name: \"createNode()\", inspect: node }\n    );\n  }\n};\n\n/**\n * Creates a IText Node\n */\nexport function createTextNode(text?: string): IText {\n  if (!text) {\n    return new Text(\"\");\n  }\n\n  const frag = createFragment(text);\n  if (isTextNodeLike(frag)) {\n    return frag.firstChild as unknown as IText;\n  } else {\n    throw new HappyMishap(\n      `The HTML passed in cannot be converted to a single text node: \"${text}\".`,\n      { name: \"createFragment(text)\", inspect: frag }\n    );\n  }\n}\n\nexport function createCommentNode(comment?: string): IComment {\n  return new Comment(comment) as IComment;\n}\n\n/**\n * Creates an element node and can preserve parent relationship if known\n */\nexport const createElement = (\n  el: Container | HTML,\n  parent?: IElement\n): IElement =>\n  solveForNodeType()\n    .outputType<IElement>()\n    .solver({\n      node: (n) => {\n        if (isElement(n)) {\n          return createElement(n) as IElement;\n        } else {\n          throw new HappyMishap(\n            \"can't create an IElement from an INode node because it doesn't have a tagName property\",\n            { inspect: n }\n          );\n        }\n      },\n      html: (h) => {\n        const frag = createFragment(h);\n        if (isElementLike(frag)) {\n          if (parent) {\n            parent.append(frag.firstElementChild);\n            return parent?.lastElementChild;\n          }\n\n          return frag.firstElementChild;\n        } else {\n          throw new HappyMishap(\n            \"The HTML passed into createElement() is not convertible to a IElement node!\",\n            { name: \"createElement(html)\", inspect: frag }\n          );\n        }\n      },\n      element: identity,\n      text: (t) => {\n        throw new HappyMishap(\n          \"An IElement can not be created from a IText node because element's require a wrapping tag name!\",\n          { name: \"createElement(text)\", inspect: t }\n        );\n      },\n      comment: (t) => {\n        throw new HappyMishap(\n          \"An IElement can not be created from a IComment node because element's require a wrapping tag name!\",\n          { name: \"createElement(comment)\", inspect: t }\n        );\n      },\n      fragment: (f) => {\n        if (isElement(f.firstElementChild)) {\n          return f.firstElementChild as IElement;\n        } else {\n          throw new HappyMishap(\n            `Unable to create a IElement node from: \\n\\n${toHtml(f)}`,\n            { name: \"createElement()\" }\n          );\n        }\n      },\n      document: (d) => {\n        if (isElementLike(d)) {\n          if (parent) {\n            throw new HappyMishap(\n              \"A Document and a parent IElement were passed into createElement. This is not a valid combination!\"\n            );\n          }\n\n          return d.firstElementChild;\n        } else {\n          throw new HappyMishap(\n            \"Can not create an Element from passed in Document\",\n            { name: \"createElement(document)\", inspect: d }\n          );\n        }\n      },\n    })(el);\n\nexport interface CssVariable {\n  prop: string;\n  value: string | number | boolean;\n}\n\nexport type ClassDefn = Record<string, string | boolean | number>;\nexport type MultiClassDefn = [selector: string, keyValues: ClassDefn][];\n\nexport interface ClassApi {\n  /** add a child selector */\n  addChild: (selector: string, defn: ClassDefn) => ClassApi;\n  /** add CSS prop/values */\n  addProps: (defn: ClassDefn) => ClassApi;\n}\n\nexport interface InlineStyle {\n  /** add a single CSS variable (at a time); the CSS scope will ':root' unless specified */\n  addCssVariable: (\n    prop: string,\n    value: string | number | boolean,\n    scope?: string\n  ) => InlineStyle;\n  addClassDefinition: (\n    selection: string,\n    cb: (api: ClassApi) => void\n  ) => InlineStyle;\n  addCssVariables: (\n    dictionary: Record<string, string>,\n    scope?: string\n  ) => InlineStyle;\n  convertToVueStyleBlock: (\n    lang: \"css\" | \"scss\",\n    scoped: boolean\n  ) => InlineStyle;\n\n  finish: () => IElement;\n}\n\nconst renderClasses = (klasses: MultiClassDefn) => {\n  return klasses\n    .map(\n      ([selector, defn]) =>\n        `\\n\\n  ${selector} {\\n${Object.keys(defn)\n          .map((p) => `    ${dasherize(p)}: ${defn[p]};`)\n          .join(\"\\n\")}\\n  }`\n    )\n    .join(\"\\n\");\n};\n\n/**\n * Creates a new `<style>...</style>` node and provides a simple API surface to allow\n * populating the contents with inline CSS content\n */\nexport const createInlineStyle = <T extends string = \"text/css\">(\n  type: T = \"text/css\" as T\n) => {\n  const cssVariables: Record<string, CssVariable[]> = {};\n  const cssClasses: MultiClassDefn = [];\n  let isVueBlock = false;\n  let isScoped = true;\n  let vueLang: \"css\" | \"scss\" = \"css\";\n\n  const api: InlineStyle = {\n    addCssVariable(\n      prop: string,\n      value: string | number | boolean,\n      scope = \":root\"\n    ) {\n      if (!(scope in cssVariables)) {\n        cssVariables[scope] = [];\n      }\n      cssVariables[scope].push({ prop: prop.replace(/^--/, \"\"), value });\n\n      return api;\n    },\n    addClassDefinition(selector, cb) {\n      const classApi: ClassApi = {\n        addChild: (child, defn) => {\n          const childSelector = `${selector} ${child}`;\n          cssClasses.push([childSelector, defn]);\n          return classApi;\n        },\n        addProps: (defn) => {\n          cssClasses.push([selector, defn]);\n          return classApi;\n        },\n      };\n      cb(classApi);\n      return api;\n    },\n    addCssVariables(\n      dictionary: Record<string, string | number | boolean>,\n      scope = \":root\"\n    ) {\n      for (const p of Object.keys(dictionary)) {\n        api.addCssVariable(p, dictionary[p], scope);\n      }\n\n      return api;\n    },\n    convertToVueStyleBlock(lang, scoped = true) {\n      vueLang = lang;\n      isVueBlock = true;\n      isScoped = scoped;\n\n      return api;\n    },\n\n    finish() {\n      const setVariable = (scope: string, defn: Record<string, any>) =>\n        `${scope} {\\n${Object.keys(defn)\n          .map(\n            (prop) =>\n              `    --${defn[prop].prop}: ${defn[prop].value}${\n                String(defn.prop).endsWith(\";\") ? \"\" : \";\"\n              }`\n          )\n          .join(\"\\n\")}\\n  }`;\n\n      let text = \"\";\n      // variables\n      for (const v of Object.keys(cssVariables)) {\n        text = `${text}${setVariable(v, cssVariables[v])}\\n`;\n      }\n      // classes\n      text = `${text}${renderClasses(cssClasses)}`;\n\n      return isVueBlock\n        ? createElement(\n            `<style lang=\"${vueLang}\"${\n              isScoped ? \" scoped\" : \"\"\n            }>\\n${text}\\n</style>`\n          )\n        : createElement(`<style type=\"${type}\">\\n${text}\\n</style>`);\n    },\n  };\n\n  return api;\n};\n","import { relative } from \"node:path\";\nimport callsites from \"callsites\";\nimport { inspect } from \"./diagnostics\";\nimport { isHappyWrapperError, isInspectionTuple } from \"./type-guards\";\n\nexport interface StackLine {\n  fn: string | undefined;\n  line: number | undefined;\n  file: string | undefined;\n}\n\nexport class HappyMishap extends Error {\n  public name = \"HappyWrapper\";\n  public readonly kind: \"HappyWrapper\" = \"HappyWrapper\";\n  public trace: string[] = [];\n  public readonly line: number | null;\n  public readonly fn: string;\n  public readonly file: string;\n  public readonly structuredStack: StackLine[];\n  public toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n    };\n  }\n\n  public toString() {\n    return {\n      name: this.name,\n      message: this.message,\n    };\n  }\n\n  constructor(\n    message: string,\n    options: {\n      error?: unknown;\n      inspect?: unknown;\n      name?: string;\n    } = {}\n  ) {\n    super();\n    this.message = `\\n${message}`;\n    if (options.name) {\n      this.name = `HappyWrapper::${options.name || \"unknown\"}`;\n    }\n\n    try {\n      const sites = callsites();\n      this.structuredStack =\n        (sites || []).slice(1).map((i) => {\n          return {\n            fn:\n              i.getFunctionName() ||\n              i.getMethodName() ||\n              i.getFunction()?.name ||\n              \"\",\n            line: i.getLineNumber() || undefined,\n            file: i.getFileName()\n              ? relative(process.cwd(), i.getFileName() as string)\n              : \"\",\n          };\n        }) || [];\n    } catch {\n      this.structuredStack = [];\n    }\n\n    this.fn = this.structuredStack[0].fn || \"\";\n    this.file = this.structuredStack[0].file || \"\";\n    this.line = this.structuredStack[0].line || null;\n\n    // proxy if already a HappyWrapper\n    if (isHappyWrapperError(options.error)) {\n      this.name = `[file: ${this.file}, line: ${this.line}] HappyWrapper::${\n        options.name || options.error.name\n      }`;\n    }\n\n    if (options.error) {\n      const name =\n        options.error instanceof Error\n          ? options.error.name.replace(\"HappyWrapper::\", \"\")\n          : \"unknown\";\n      const underlying = `\\n\\nThe underlying error message [${name}] was:\\n${\n        options.error instanceof Error\n          ? options.error.message\n          : String(options.error)\n      }`;\n      this.message = `${this.message}${underlying}`;\n      this.trace = [...this.trace, name];\n    } else {\n      if (options.inspect) {\n        const inspections = isInspectionTuple(options.inspect)\n          ? [options.inspect]\n          : Array.isArray(options.inspect)\n          ? options.inspect\n          : [options.inspect];\n\n        for (const [idx, i] of inspections.entries()) {\n          const intro = isInspectionTuple(i) ? `${i[0]}\\n` : `${[idx]}:\\n`;\n          const container = isInspectionTuple(i) ? i[1] : i;\n\n          this.message = `${this.message}\\n\\n${intro}${JSON.stringify(\n            inspect(container),\n            null,\n            2\n          )}`;\n        }\n      }\n      if (this.trace.length > 1) {\n        this.message = `${this.message}\\n\\nTrace:${this.trace.map(\n          (i, idx) => `${idx}. ${i}`\n        )}`;\n      }\n    }\n\n    this.message = `${this.message}\\n`;\n    for (const l of this.structuredStack) {\n      this.message = l.file?.includes(\".pnpm\")\n        ? this.message\n        : `${this.message}\\n  - ${l.fn ? `${l.fn}() ` : \"\"}${l.file}:${l.line}`;\n    }\n    this.structuredStack = [];\n  }\n}\n","export default function callsites() {\n\tconst _prepareStackTrace = Error.prepareStackTrace;\n\tError.prepareStackTrace = (_, stack) => stack;\n\tconst stack = new Error().stack.slice(1); // eslint-disable-line unicorn/error-message\n\tError.prepareStackTrace = _prepareStackTrace;\n\treturn stack;\n}\n","/* eslint-disable no-use-before-define */\nimport { flow, pipe } from \"fp-ts/lib/function.js\";\nimport { getClassList } from \"./attributes\";\nimport { createFragment } from \"./create\";\nimport type {\n  Container,\n  ContainerOrHtml,\n  HTML,\n  NodeSolverReady,\n  Tree,\n  TreeSummary,\n  UpdateSignature,\n} from \"./happy-types\";\nimport { getChildren, into } from \"./nodes\";\nimport {\n  isContainer,\n  isElement,\n  isElementLike,\n  isTextNode,\n  isTextNodeLike,\n  isUpdateSignature,\n} from \"./type-guards\";\nimport { getNodeType, solveForNodeType, toHtml } from \"./utils\";\nimport type { HappyDoc, Fragment, IElement, INode } from \"./index\";\n\nfunction descClass(n: Container) {\n  const list = getClassList(n);\n  return list.length > 0 ? `{ ${list.join(\" \")} }` : \"\";\n}\n\nfunction descFrag(n: Fragment) {\n  // eslint-disable-next-line no-use-before-define\n  const children = getChildren(n).map((i) => describeNode(i));\n  return isElementLike(n)\n    ? `[el: ${n.firstElementChild.tagName.toLowerCase()}]${descClass}`\n    : isTextNodeLike(n)\n    ? `[text: ${n.textContent.slice(0, 4).replace(/\\n+/g, \"\")}...]`\n    : `[children: ${children.length > 0 ? `${children.join(\", \")}` : \"none\"}]`;\n}\n\nexport const describeNode = (\n  node: Container | HTML | null | UpdateSignature | any[]\n): string => {\n  if (!node) {\n    return node === null ? \"[null]\" : \"undefined\";\n  } else if (isUpdateSignature(node)) {\n    return `UpdateSignature(${describeNode(node[0])})`;\n  } else if (Array.isArray(node)) {\n    return node.map((i) => describeNode(i)).join(\"\\n\");\n  }\n\n  return solveForNodeType()\n    .outputType<string>()\n    .solver({\n      html: (h) => pipe(h, createFragment, describeNode),\n      node: (n) => `node${descClass(n)}`,\n      text: (t) => `text[${t.textContent.slice(0, 5).replace(\"\\n\", \"\")}...]`,\n      comment: (t) =>\n        `comment[${t.textContent.slice(0, 5).replace(\"\\n\", \"\")}...]`,\n      element: (e) => `element[${e.tagName.toLowerCase()}]${descClass(e)}`,\n      fragment: (f) => `fragment${descFrag(f)}`,\n      document: (d) =>\n        `doc[head: ${!!d.head}, body: ${!!d.body}]: ${describeNode(\n          createFragment(d.body)\n        )}`,\n    })(node);\n};\n\nexport const inspect = <T extends boolean>(\n  item?: unknown,\n  toJSON: T = false as T\n): false extends T ? Record<string, any> : string => {\n  const solver = Array.isArray(item)\n    ? () => item.map((i) => describeNode(i))\n    : solveForNodeType()\n        .outputType<Record<string, any>>()\n        .solver({\n          html: (h) => pipe(h, createFragment, (f) => inspect(f)),\n          fragment: (x) => ({\n            kind: \"Fragment\",\n            children: `${x.children.length} / ${x.childNodes.length}`,\n            ...(x.childNodes.length > 1\n              ? {\n                  leadsWith: isElement(x.firstChild)\n                    ? \"element\"\n                    : isTextNode(x.firstChild)\n                    ? \"text\"\n                    : \"other\",\n                  endsWith: isElement(x.lastChild)\n                    ? \"element\"\n                    : isTextNode(x.lastChild)\n                    ? \"text\"\n                    : \"other\",\n                }\n              : {\n                  childNode: inspect(x.firstChild),\n                }),\n            content:\n              x.textContent.length > 128\n                ? `${x.textContent.slice(0, 128)} ...`\n                : x.textContent,\n            childDetails: x.childNodes.map((i) => {\n              try {\n                return {\n                  html: toHtml(i),\n                  nodeType: getNodeType(i),\n                  hasParentElement: !!i.parentElement,\n                  hasParentNode: i.parentNode\n                    ? `${getNodeType(i.parentNode)} [type:${\n                        i.parentNode.nodeType\n                      }]`\n                    : false,\n                  childNodes: i.childNodes.length,\n                };\n              } catch {\n                return \"N/A\";\n              }\n            }),\n            html: toHtml(x),\n          }),\n          document: (x) => ({\n            kind: \"Document\",\n            headerChildren: x.head.childNodes?.length,\n            bodyChildren: x.body.childNodes?.length,\n            body: toHtml(x.body),\n            children: `${x.body.children?.length} / ${x.body.childNodes?.length}`,\n            childTextContent: x.body.childNodes.map((i) => i.textContent),\n            childDetails: x.childNodes.map((i) => {\n              try {\n                return {\n                  html: toHtml(i),\n                  nodeType: getNodeType(i),\n                  hasParentElement: !!i.parentElement,\n                  hasParentNode: i.parentNode\n                    ? `${getNodeType(i.parentNode)} [type:${\n                        i.parentNode.nodeType\n                      }]`\n                    : false,\n                  childNodes: i.childNodes.length,\n                };\n              } catch {\n                return \"N/A\";\n              }\n            }),\n          }),\n          text: (x) => ({\n            kind: \"IText node\",\n            textContent:\n              x.textContent.length > 128\n                ? `${x.textContent.slice(0, 128)} ...`\n                : x.textContent,\n            children: x.childNodes?.length,\n            childContent: x.childNodes?.map((i) => i.textContent),\n          }),\n          comment: (c) => ({\n            kind: \"IComment node\",\n            textContent:\n              c.textContent.length > 128\n                ? `${c.textContent.slice(0, 128)} ...`\n                : c.textContent,\n            children: c.childNodes?.length,\n            childContent: c.childNodes?.map((i) => i.textContent),\n          }),\n          element: (x) => ({\n            kind: \"IElement node\",\n            tagName: x.tagName,\n            classes: getClassList(x),\n            /**\n             * in functions like wrap and pretty print, a \"parent element\" is provided\n             * as a synthetic parent but if this flag indicates whether the flag has\n             * a connected parent in a DOM tree.\n             */\n            hasNaturalParent: !!x.parentElement,\n            ...(x.parentElement\n              ? { parent: describeNode(x.parentElement) }\n              : {}),\n            textContent: x.textContent,\n            children: `${x.children.length} / ${x.childNodes.length}`,\n            childContent: x.childNodes?.map((i) => i.textContent),\n            childDetails: x.childNodes.map((i) => {\n              try {\n                return {\n                  html: toHtml(i),\n                  nodeType: getNodeType(i),\n                  hasParentElement: !!i.parentElement,\n                  hasParentNode: i.parentNode\n                    ? `${getNodeType(i.parentNode)} [type:${\n                        i.parentNode.nodeType\n                      }]`\n                    : false,\n                  childNodes: i.childNodes.length,\n                };\n              } catch {\n                return \"N/A\";\n              }\n            }),\n            html: truncate(512)(toHtml(x)),\n          }),\n          node: (n) => ({\n            kind: \"INode (generic)\",\n            looksLike: isElement(n)\n              ? \"element\"\n              : isTextNode(n)\n              ? \"text\"\n              : \"unknown\",\n            children: `${n.childNodes?.length}`,\n            childContent: n.childNodes?.map((i) => truncate(128)(i.textContent)),\n            html: truncate(512)(n.toString()),\n          }),\n        });\n  const result =\n    isContainer(item) || typeof item === \"string\"\n      ? solver(item)\n      : {\n          result: \"not found\",\n          type: typeof item,\n          ...(typeof item === \"object\" && item !== null\n            ? { keys: Object.keys(item as Object) }\n            : { value: JSON.stringify(item) }),\n        };\n  return (toJSON ? JSON.stringify(result, null, 2) : result) as false extends T\n    ? Record<string, any>\n    : string;\n};\n\nconst removeSpecialChars = (input: string) =>\n  input.replace(/\\\\t/g, \"\").replace(/\\\\n/g, \"\").trim();\nconst truncate = (maxLength: number) => (input: string) =>\n  input.slice(0, maxLength);\n\nexport const tree = (node: Container | HTML): Tree => {\n  const summarize = (tree: Omit<Tree, \"summary\">): Tree => {\n    const summary = (n: Omit<Tree, \"summary\">): TreeSummary => {\n      let ts: TreeSummary;\n      switch (n.type) {\n        case \"text\": {\n          ts = {\n            node: `t(${pipe(\n              n.node.textContent,\n              removeSpecialChars,\n              truncate(10)\n            )})`,\n            children: n.children.map((c) => summary(c)),\n          };\n          break;\n        }\n        case \"comment\": {\n          ts = {\n            node: `c(${pipe(\n              n.node.textContent,\n              removeSpecialChars,\n              truncate(10)\n            )})`,\n            children: n.children.map((c) => summary(c)),\n          };\n          break;\n        }\n        case \"element\": {\n          const el = n.node as IElement;\n          ts = {\n            node: `el(${el.tagName.toLowerCase()})`,\n            children: n.children.map((c) => summary(c)),\n          };\n          break;\n        }\n        case \"node\": {\n          const node = n.node as INode;\n          ts = {\n            node: `n(${\n              pipe(node.nodeName, removeSpecialChars, truncate(10)) ||\n              pipe(node.textContent, removeSpecialChars, truncate(10))\n            }`,\n            children: n.children.map((c) => summary(c)),\n          };\n          break;\n        }\n        case \"fragment\": {\n          const f = n.node as Fragment;\n          ts = {\n            node: `frag(${\n              f.firstElementChild\n                ? f.firstElementChild.tagName.toLowerCase()\n                : removeSpecialChars(f.textContent).trim().slice(0, 10)\n            })`,\n            children: n.children.map((c) => summary(c)),\n          };\n          break;\n        }\n        case \"document\": {\n          const d = n.node as HappyDoc;\n          ts = {\n            node: `doc(${\n              isElementLike(d)\n                ? d.body.firstElementChild.tagName.toLowerCase()\n                : d.textContent.slice(0, 10)\n            })`,\n            children: n.children.map((c) => summary(c)),\n          };\n          break;\n        }\n        default: {\n          ts = {\n            node: `u(${n.toString()})`,\n            children: n.children.map((c) => summary(c)),\n          };\n          break;\n        }\n      }\n      return ts;\n    };\n\n    const recurse =\n      (level = 0) =>\n      (node: TreeSummary): string => {\n        const indent = `${\"\".padStart(level * 6, \" \")}${\n          level > 0 ? `${level}) ` : \"ROOT: \"\n        }`;\n        return `${indent}${node.node} ${\n          node.children.length > 0 ? \"⤵\" : \"↤\"\n        }\\n${node.children.map((i) => recurse(level + 1)(i))}`;\n      };\n\n    return {\n      ...tree,\n      summary: () => summary(tree),\n      toString: () => {\n        const describe = summary(tree);\n        return `\\nTree Summary: ${describe.node}\\n${\"\".padStart(\n          40,\n          \"-\"\n        )}\\n${recurse(0)(describe)}`;\n      },\n    };\n  };\n\n  const convert = (level: number): NodeSolverReady<never, Tree> =>\n    solveForNodeType()\n      .outputType<Tree>()\n      .solver({\n        html: flow(createFragment, tree),\n        text: (t) =>\n          summarize({\n            type: \"text\",\n            node: t,\n            level,\n            children: t.childNodes.map((c) => convert(level + 1)(c)),\n          }),\n        comment: (c) =>\n          summarize({\n            type: \"comment\",\n            node: c,\n            level,\n            children: c.childNodes.map((i) => convert(level + 1)(i)),\n          }),\n        element: (e) =>\n          summarize({\n            type: \"element\",\n            node: e,\n            level,\n            children: e.childNodes.map((c) => convert(level + 1)(c)),\n          }),\n        node: (n) =>\n          summarize({\n            type: \"node\",\n            node: n,\n            level,\n            children: n.childNodes.map((c) => convert(level + 1)(c)),\n          }),\n        fragment: (f) =>\n          summarize({\n            type: \"fragment\",\n            node: f,\n            level,\n            children: f.childNodes.map((c) => convert(level + 1)(c)),\n          }),\n        document: (d) =>\n          summarize({\n            type: \"document\",\n            node: d,\n            level,\n            children: d.childNodes.map((c) => convert(level + 1)(c)),\n          }),\n      });\n\n  return convert(0)(node);\n};\n\n/**\n * Allows various content-types to be wrapped into a single\n * Fragment which contains each element as a sibling\n */\nexport const siblings = <C extends UpdateSignature | ContainerOrHtml[]>(\n  ...content: C\n) => {\n  return into()(...content);\n};\n","/* eslint-disable unicorn/prefer-logical-operator-over-ternary */\nimport { pipe } from \"fp-ts/lib/function.js\";\nimport { HappyMishap } from \"./errors\";\nimport {\n  createDocument,\n  createElement,\n  createFragment,\n  createNode,\n} from \"./create\";\nimport type {\n  Container,\n  ContainerOrHtml,\n  DocRoot,\n  HTML,\n  UpdateSignature,\n} from \"./happy-types\";\nimport {\n  isDocument,\n  isElement,\n  isElementLike,\n  isFragment,\n  isTextNode,\n  isTextNodeLike,\n  isUpdateSignature,\n} from \"./type-guards\";\nimport { clone, getNodeType, solveForNodeType, toHtml } from \"./utils\";\nimport {\n  addClass,\n  Fragment,\n  getClassList,\n  HappyDoc,\n  IElement,\n  IText,\n} from \"./index\";\n\n/**\n * converts a IHTMLCollection or a INodeList to an array\n */\nexport const getChildren = (el: Container): (IElement | IText)[] => {\n  if (!el.hasChildNodes()) {\n    return [];\n  }\n\n  const output: (IElement | IText)[] = [];\n  let child = el.firstChild as IElement | IText;\n\n  for (let idx = 0; idx < el.childNodes.length; idx++) {\n    if (isElement(child) || isTextNode(child)) {\n      output.push(child);\n    } else if (isFragment(child) || isDocument(child)) {\n      for (const fragChild of getChildren(child)) {\n        output.push(fragChild);\n      }\n    } else {\n      throw new HappyMishap(\n        `unknown node type [${getNodeType(\n          child\n        )}] found while trying to convert children to an array`,\n        { name: \"getChildrenAsArray\", inspect: child }\n      );\n    }\n\n    child = child.nextSibling as IElement | IText;\n  }\n\n  return output;\n};\n\nexport const getChildElements = (el: Container): IElement[] => {\n  return getChildren(el).filter((c) => isElement(c)) as IElement[];\n};\n\n/**\n * Extracts a node from a DOM tree; is designed to be used with `update/updateAll()`\n * and the `updateChildren()` utilities. It can remove a set of elements as well as retain the extracted elements in\n * an array of nodes.\n * ```\n * const memory = []\n * domTree = select(domTree)\n *  .updateAll('.bad-juju')(extract(memory))\n *  .toContainer()\n * ```\n */\nexport const extract =\n  <M extends (IElement | IText) | IElement | undefined>(memory?: M[]) =>\n  <T extends IElement extends M ? IElement : IElement | IText>(\n    node: T\n  ): false => {\n    if (memory) {\n      memory.push(clone(node) as T & M);\n    }\n    return false; // indicates that node passed in should be removed\n  };\n\n/**\n * **placeholder**\n *\n * Very similar to the `extract()` utility where it allows certain elements to be\n * removed from the DOM tree and stored in a separate variable but in this case\n * rather then leaving _nothing_ in it's place we can instead leave a _placeholder_ node.\n *\n * If you want to define what this placeholder node should look like you may --\n * by setting the optional `placeholder` element -- but by default you will get:\n *\n * ```html\n * <placeholder></placeholder>\n * ```\n *\n * But all classes on removed element will be retained.\n */\nexport const placeholder =\n  <M extends (IElement | IText) | IElement | undefined>(\n    memory?: M[],\n    placeholder?: IElement\n  ) =>\n  <T extends IElement>(node: T): IElement => {\n    if (memory) {\n      memory.push(clone(node) as T & M);\n    }\n    const el = placeholder\n      ? placeholder\n      : createElement(\"<placeholder></placeholder>\");\n    addClass(...getClassList(node))(el);\n    node.replaceWith(el);\n\n    return node;\n  };\n\n/**\n * Replaces an existing element with a brand new one while preserving the element's\n * relationship to the parent node (if one exists).\n */\nexport const replaceElement =\n  (newElement: IElement | HTML) =>\n  (oldElement: IElement): IElement => {\n    const parent = oldElement.parentElement;\n    if (isElement(parent) || isTextNode(parent)) {\n      parent.replaceChild(createElement(newElement), oldElement);\n    }\n\n    const newEl =\n      typeof newElement === \"string\" ? createElement(newElement) : newElement;\n\n    if (parent) {\n      const children = getChildElements(parent);\n      const childIdx = children.findIndex(\n        (c) => toHtml(c) === toHtml(oldElement)\n      );\n      // match on first child index which produces the same HTML output\n      const updated: IElement[] = (children || []).map((c, i) =>\n        i === childIdx ? newEl : c\n      );\n      parent.replaceChildren(...updated);\n    }\n    return newEl;\n  };\n\n/**\n * Appends one or more nodes to a parent container\n */\nexport const append = <N extends ContainerOrHtml[]>(...nodes: N | N[]) => {\n  const n = nodes.flat();\n  return <P extends UpdateSignature | ContainerOrHtml>(\n    parent: P\n  ): P extends Array<any> ? IElement : P => {\n    const result = solveForNodeType(\"text\", \"node\", \"comment\")\n      .mirror()\n      .solver({\n        html: (h) => pipe(h, createElement, append(...nodes), toHtml),\n        element: (e) => {\n          for (const i of n) {\n            e.append(i);\n          }\n          return e;\n        },\n        fragment: (f) => {\n          for (const i of n) {\n            f.append(i);\n          }\n          return f;\n        },\n        document: (d) => {\n          for (const i of n) {\n            d.body.append(i);\n          }\n          return d;\n        },\n      })(isUpdateSignature(parent) ? parent[0] : parent);\n\n    return result as P extends Array<any> ? IElement : P;\n  };\n};\n\n/**\n * A _partially applied_ instance of the `into()` utility; currently waiting\n * for child/children nodes.\n *\n * Note: the return type of this function is the Parent node (in whatever)\n * container type was passed in. However, child element(s) being wrapped which\n * had reference to a parent node, will have their parent node updated to\n * point now to the new parent node instead. This is important for proper\n * mutation when using the update/updateAll() utilities.\n */\nexport type IntoChildren<P extends DocRoot | IElement | HTML | undefined> = <\n  A extends UpdateSignature | ContainerOrHtml[] | ContainerOrHtml[][]\n>(\n  ...args: A\n) => A extends UpdateSignature\n  ? IElement | false\n  : undefined extends P\n  ? Fragment\n  : P;\n\n/**\n * A higher order function which starts by receiving a _wrapper_ component\n * and then is fully applied when the child nodes are passed in.\n *\n * This is the _inverse_ of the **wrap()** utility.\n *\n * ```ts\n * const sandwich = into(bread)(peanut, butter, jelly)\n * ```\n */\nexport const into =\n  <P extends DocRoot | IElement | HTML | undefined>(\n    /** The parent container which will wrap the child content */\n    parent?: P\n  ): IntoChildren<P> =>\n  <C extends UpdateSignature | ContainerOrHtml[] | ContainerOrHtml[][]>(\n    ...content: C\n  ): C extends UpdateSignature\n    ? IElement | false\n    : undefined extends P\n    ? Fragment\n    : P => {\n    /**\n     * Keeps track of whether the incoming parent was wrapped in a temporary\n     * document fragment.\n     */\n    const wrapped = !!(typeof parent === \"string\");\n\n    /**\n     * Upgrade HTML or undefined values for parent to ensure\n     * that no matter what's passed in, the parent is some sort\n     * valid container\n     */\n    let normalizedParent: DocRoot | IElement = wrapped\n      ? createFragment(parent)\n      : isElement(parent)\n      ? parent\n      : parent\n      ? parent\n      : createFragment();\n\n    // flatten children passed in to support both arrays and destructed arrays\n    const flat = isUpdateSignature(content)\n      ? [content[0]] // first element is what's being used; discard index and count\n      : content.flatMap((c) => c as Container | string);\n\n    if (isTextNodeLike(normalizedParent)) {\n      throw new HappyMishap(\n        `The wrapper node -- when calling into() -- is wrapping a text node; this is not allowed. Parent HTML: \"${toHtml(\n          normalizedParent\n        )}\"`,\n        {\n          name: \"into()\",\n          inspect: [[\"parent node\", parent]],\n        }\n      );\n    }\n\n    const contentHtml = flat.map((c) => toHtml(c)).join(\"\");\n    const transient = createFragment(contentHtml);\n    const parentHasChildElements = normalizedParent.childElementCount > 0;\n\n    if (parentHasChildElements) {\n      for (const c of getChildren(transient)) {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        normalizedParent.firstChild.appendChild(clone(c));\n      }\n    } else {\n      for (const c of getChildren(transient)) {\n        normalizedParent.append(c);\n      }\n    }\n\n    // if this call was made as part of an update operation we'll return\n    // the parent as an IElement (even if it was wrapped in a fragment)\n    // and make sure that the element passed in is replaced with the parent\n    if (isUpdateSignature(content) && isElement(content[0])) {\n      normalizedParent = isElementLike(normalizedParent)\n        ? normalizedParent.firstElementChild\n        : createElement(normalizedParent);\n\n      content[0].replaceWith(normalizedParent);\n    }\n\n    return (\n      wrapped && !isUpdateSignature(content)\n        ? toHtml(normalizedParent)\n        : normalizedParent\n    ) as C extends UpdateSignature\n      ? IElement | false\n      : undefined extends P\n      ? Fragment\n      : P;\n  };\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type ChangeTagNameTo<T extends string> = <\n  E extends [IElement | HTML | HappyDoc | Fragment] | UpdateSignature\n>(\n  ...el: E\n) => E extends UpdateSignature ? IElement : E;\n\n/**\n * Changes the tag name for the top level container element passed in\n * while preserving the parent node relationship.\n * ```ts\n * // <div>hi</div>\n * const html = changeTagName('div')(`<span>hi</span`)\n * ```\n */\nexport const changeTagName =\n  <T extends string>(tagName: T): ChangeTagNameTo<T> =>\n  <A extends [IElement | HTML | HappyDoc | Fragment] | UpdateSignature>(\n    ...args: A\n  ): A extends UpdateSignature ? IElement : A => {\n    const node = args[0];\n    /** uses regex to modify tag name to new value */\n    const replacer = (el: IElement, tagName: string) => {\n      const open = new RegExp(`^<${el.tagName.toLowerCase()}`);\n      const close = new RegExp(`<\\/${el.tagName.toLowerCase()}>$`);\n\n      const newTag = toHtml(el)\n        .replace(open, `<${tagName}`)\n        .replace(close, `</${tagName}>`);\n      if (el.parentNode && el.parentNode !== null) {\n        el.parentNode.replaceChild(createNode(newTag), el);\n      }\n\n      return newTag;\n    };\n\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    const areTheSame = (before: string, after: string) =>\n      before.toLocaleLowerCase() === after.toLocaleLowerCase();\n\n    return solveForNodeType()\n      .mirror()\n      .solver({\n        html: (h) => {\n          const before = createFragment(h).firstElementChild.tagName;\n          return areTheSame(before, tagName)\n            ? h\n            : toHtml(replacer(createFragment(h).firstElementChild, tagName));\n        },\n        text: (t) => {\n          throw new HappyMishap(\n            \"Attempt to change a tag name for a IText node. This is not allowed.\",\n            { inspect: t, name: \"changeTagName(IText)\" }\n          );\n        },\n        comment: (t) => {\n          throw new HappyMishap(\n            \"Attempt to change a tag name for a IComment node. This is not allowed.\",\n            { inspect: t, name: \"changeTagName(IComment)\" }\n          );\n        },\n        node: (n) => {\n          throw new HappyMishap(\n            \"Attempt to change a generic INode node's tag name. This is not allowed.\",\n            { inspect: n, name: \"changeTagName(INode)\" }\n          );\n        },\n        element: (el) =>\n          areTheSame(el.tagName, tagName)\n            ? el\n            : replaceElement(replacer(el, tagName))(el),\n\n        fragment: (f) => {\n          if (f.firstElementChild) {\n            if (f.firstElementChild.parentElement) {\n              f.firstElementChild.replaceWith(\n                changeTagName(tagName)(f.firstElementChild)\n              );\n            } else {\n              throw new HappyMishap(\n                \"Fragment's first child node must have a parent node to change the tag name!\",\n                { name: \"changeTagName(Fragment)\", inspect: f }\n              );\n            }\n          } else {\n            throw new HappyMishap(\n              \"Fragment passed into changeTagName() has no elements as children!\",\n              { name: \"changeTagName(Fragment)\", inspect: f }\n            );\n          }\n\n          return f;\n        },\n        document: (d) => {\n          d.body.firstElementChild.replaceWith(\n            changeTagName(tagName)(d.body.firstElementChild)\n          );\n          const body = toHtml(d.body);\n          const head = d.head.innerHTML;\n\n          return createDocument(body, head);\n        },\n      })(node) as A extends UpdateSignature ? IElement : A;\n  };\n\n/**\n * Prepends an `IElement` as the first child element of a host element.\n *\n * Note: you can use a string representation of an element\n * ```ts\n * const startWith = prepend('<h1>just do it</h1>')\n * const message: IElement = startWith(body)\n * ```\n */\nexport const prepend =\n  (prepend: IElement | IText | HTML) =>\n  (el: IElement): IElement => {\n    const p =\n      typeof prepend === \"string\"\n        ? createFragment(prepend).firstChild\n        : prepend;\n\n    el.prepend(p);\n    return el;\n  };\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type Before<_T extends ContainerOrHtml> = <\n  A extends [IElement | HTML | HappyDoc | Fragment] | UpdateSignature\n>(\n  ...afterNode: A\n) => A extends UpdateSignature ? IElement : A extends string ? string : A;\n\n/**\n * Inserts a set of Node or string objects in the children list of this Element's\n * parent, just before this Element. String objects are inserted as equivalent Text nodes.\n *\n * Note: you can use a string representation of an element\n * ```ts\n * const startWith = before('<h1>just do it</h1>')\n * const message: IElement = startWith(body)\n * ```\n */\nexport const before =\n  <B extends ContainerOrHtml>(beforeNode: B): Before<B> =>\n  <A extends [IElement | HTML | HappyDoc | Fragment] | UpdateSignature>(\n    ...afterNode: A\n  ): A extends UpdateSignature ? IElement : A extends string ? string : A => {\n    const outputIsHtml = typeof afterNode[0] === \"string\";\n    const beforeNormalized: IElement | IText =\n      typeof beforeNode === \"string\"\n        ? ((createFragment(beforeNode).firstElementChild ||\n            createFragment(beforeNode).firstChild) as IElement | IText)\n        : createNode(beforeNode);\n\n    const afterNormalized: ContainerOrHtml =\n      typeof afterNode[0] === \"string\"\n        ? createFragment(afterNode[0])\n        : isUpdateSignature(afterNode[0])\n        ? afterNode[0][0]\n        : afterNode[0];\n\n    const invalidType = (n: string | Container) => {\n      throw new HappyMishap(\n        `The before() utility was passed an invalid container type for the \"after\" node: ${getNodeType(\n          n\n        )}`,\n        {\n          name: `before(${getNodeType(beforeNormalized)})(${getNodeType(n)})`,\n          inspect: n,\n        }\n      );\n    };\n\n    const noParent = (n: string | Container) =>\n      new HappyMishap(\n        'the before() utility for depends on having a parent element in the \"afterNode\" as the parent\\'s value must be mutated. If you do genuinely want this behavior then use a Fragment (or just HTML strings)',\n        {\n          name: `before(${getNodeType(beforeNode)})(${getNodeType(n)})`,\n        }\n      );\n\n    const node = solveForNodeType()\n      .mirror()\n      .solver({\n        html: (h) => pipe(h, createFragment, before(beforeNode), toHtml),\n        text: (t) => {\n          if (!t.parentElement) {\n            throw noParent(t);\n          }\n          t.before(beforeNormalized);\n          return t;\n        },\n        comment: (t) => {\n          if (!t.parentElement) {\n            throw noParent(t);\n          }\n          t.before(beforeNormalized);\n          return t;\n        },\n        node: (n) => invalidType(n),\n        document: (d) => {\n          d.body.prepend(beforeNormalized);\n          return d;\n        },\n        fragment: (f) => {\n          f.prepend(beforeNormalized);\n          return f;\n        },\n        element: (el) => {\n          if (el.parentElement) {\n            // inject the node before this one (on parent)\n            el.before(beforeNormalized);\n\n            return el;\n          } else {\n            throw noParent(el);\n          }\n        },\n      })(afterNormalized);\n\n    return (\n      outputIsHtml && !isUpdateSignature(afterNode) ? toHtml(node) : node\n    ) as A extends UpdateSignature ? IElement : A extends string ? string : A;\n  };\n\nexport const after =\n  (afterNode: IElement | IText | HTML) =>\n  <B extends IElement | Fragment | HTML>(beforeNode: B): B => {\n    const afterNormalized =\n      typeof afterNode === \"string\"\n        ? createFragment(afterNode).firstElementChild\n        : afterNode;\n\n    const invalidType = (n: string | Container) => {\n      throw new HappyMishap(\n        `The after function was passed an invalid container type: ${getNodeType(\n          n\n        )}`,\n        { name: `after(${getNodeType(beforeNode)})(invalid)` }\n      );\n    };\n\n    return solveForNodeType()\n      .mirror()\n      .solver({\n        html: (h) => pipe(h, createFragment, after(afterNode), toHtml),\n        text: (t) => invalidType(t),\n        comment: (t) => invalidType(t),\n        node: (n) => invalidType(n),\n        document: (d) => {\n          d.body.append(afterNormalized);\n          return d;\n        },\n        fragment: (f) => {\n          f.append(afterNormalized);\n          return f;\n        },\n        element: (el) => {\n          if (el.parentElement) {\n            // inject the node before this one (on parent)\n            el.after(afterNormalized);\n\n            return el;\n          } else {\n            throw new HappyMishap(\n              'the after() utility for depends on having a parent element in the \"afterNode\" as the parent\\'s value must be mutated. If you do genuinely want this behavior then use a Fragment (or just HTML strings)',\n              { name: `after(${getNodeType(afterNode)})(IElement)` }\n            );\n          }\n        },\n      })(beforeNode);\n  };\n\n/**\n * A payload which is a partial application of the `wrap()` method and expects\n * to no w receive the parent element.\n */\nexport type ReadyForWrapper<_C extends UpdateSignature | ContainerOrHtml[]> = <\n  P extends DocRoot | IElement | HTML | undefined\n>(\n  parent: P\n) => undefined extends P ? Fragment : P;\n\n/**\n * **wrap**\n *\n * A higher order function which receives child elements which will need\n * to be wrapped and then fully applied when it receives the singular _wrapper_\n * container.\n *\n * This is the _inverse_ of the **into()** utility.\n *\n * ```ts\n * const sandwich = wrap(peanut, butter, jelly)(bread)\n * ```\n */\nexport const wrap =\n  <C extends UpdateSignature | ContainerOrHtml[]>(\n    ...children: C\n  ): ReadyForWrapper<C> =>\n  <P extends DocRoot | IElement | HTML | undefined>(parent?: P) => {\n    return into(parent)(...children) as undefined extends P ? Fragment : P;\n  };\n","/* eslint-disable no-use-before-define */\nimport { createFragment } from \"./create\";\nimport type {\n  Container,\n  DocRoot,\n  InspectionTuple,\n  UpdateSignature,\n} from \"./happy-types\";\nimport type { HappyMishap } from \"./errors\";\nimport type { Fragment, HappyDoc, IElement, IText } from \"./index\";\n\nexport function isHappyWrapperError(err: unknown): err is HappyMishap {\n  return typeof err === \"object\" && (err as any).kind === \"HappyWrapper\";\n}\n\nexport const isInspectionTuple = (thing: unknown): thing is InspectionTuple => {\n  return (\n    Array.isArray(thing) &&\n    thing.length === 2 &&\n    typeof thing[0] === \"string\" &&\n    !Array.isArray(thing[1])\n  );\n};\n\nexport function isDocument(dom: unknown): dom is HappyDoc {\n  return (\n    typeof dom === \"object\" && dom !== null && !isElement(dom) && \"body\" in dom\n  );\n}\nexport function isFragment(dom: unknown): dom is Fragment {\n  return (\n    typeof dom === \"object\" &&\n    dom !== null &&\n    !isElement(dom) &&\n    !isTextNode(dom) &&\n    !(\"body\" in dom)\n  );\n}\n\nexport const nodeStartsWithElement = <D extends DocRoot>(node: D) => {\n  return !!(\n    \"firstElementChild\" &&\n    \"firstChild\" &&\n    \"firstElementChild\" &&\n    (node as any).firstChild === (node as any).firstElementChild\n  );\n};\nexport const nodeEndsWithElement = <D extends DocRoot>(node: D) => {\n  return \"lastElementChild\" in node && node.lastChild === node.lastElementChild;\n};\n\nexport const nodeBoundedByElements = <D extends DocRoot>(node: D) => {\n  return nodeStartsWithElement(node) && nodeEndsWithElement(node);\n};\n\n/**\n * tests whether a given node has a singular Element as a child\n * of the given node\n */\nexport const hasSingularElement = <N extends DocRoot>(node: N) => {\n  return nodeBoundedByElements(node) && node.childNodes.length === 1;\n};\n\nexport function isElement(el: unknown): el is IElement {\n  return (\n    typeof el === \"object\" &&\n    el !== null &&\n    \"outerHTML\" in (el as Object) &&\n    (el as any).nodeType === 1\n  );\n}\n\n/**\n * determines if a Doc/DocFragment is a wrapper for only a singular\n * `IElement` node\n */\nexport const isElementLike = (container: unknown) => {\n  if (isDocument(container)) {\n    return (\n      container.body.childNodes.length === 1 &&\n      container.body.firstChild === container.body.firstElementChild\n    );\n  }\n\n  return (\n    isFragment(container) &&\n    container.childNodes.length === 1 &&\n    container.firstChild === container.firstElementChild\n  );\n};\n\n/**\n * Tests whether a doc type is wrapping only a text node\n */\nexport function isTextNodeLike(node: unknown) {\n  return (\n    (isDocument(node) || isFragment(node)) &&\n    node?.childNodes?.length === 1 &&\n    isTextNode(node.firstChild)\n  );\n}\n\n/**\n * Type guard which detects that the incoming calling signature matches\n * that of the `select()` utilities update/updateAll operation.\n */\nexport const isUpdateSignature = (args: unknown): args is UpdateSignature => {\n  return (\n    Array.isArray(args) &&\n    args.length === 3 &&\n    // && (typeof args[0] === 'string' || typeof args[0] === 'object')\n    typeof args[1] === \"number\" &&\n    typeof args[2] === \"number\"\n  );\n};\n\nexport function isTextNode(node: unknown): node is IText {\n  if (typeof node === \"string\") {\n    const test = createFragment(node);\n    return isTextNodeLike(test);\n  } else {\n    return (\n      typeof node === \"object\" &&\n      node !== null &&\n      !(\"firstElementChild\" in (node as any))\n    );\n  }\n}\n\nexport const isContainer = (thing: unknown): thing is Container => {\n  return (\n    isDocument(thing) ||\n    isFragment(thing) ||\n    isElement(thing) ||\n    isTextNode(thing)\n  );\n};\n\n/**\n * detects whether _all_ children of a give node are Elements\n */\nexport const nodeChildrenAllElements = <D extends DocRoot>(node: D) => {\n  return node.childNodes.every((n) => isElement(n));\n};\n","import { flow, pipe } from \"fp-ts/lib/function.js\";\nimport {\n  createCommentNode,\n  createDocument,\n  createElement,\n  createFragment,\n  createTextNode,\n} from \"./create\";\nimport { HappyMishap } from \"./errors\";\nimport type {\n  Container,\n  ContainerOrHtml,\n  HTML,\n  NodeSolver,\n  NodeSolverReceiver,\n  NodeType,\n} from \"./happy-types\";\nimport {\n  isDocument,\n  isElement,\n  isElementLike,\n  isFragment,\n  isTextNode,\n} from \"./type-guards\";\n\n/**\n * Use the self-reported numeric type that a node presents\n * to identify what type it is.\n */\nexport const nodeTypeLookup = (type: number): NodeType | undefined => {\n  switch (type) {\n    case 1: {\n      return \"element\";\n    }\n    case 3: {\n      return \"text\";\n    }\n    case 8: {\n      return \"comment\";\n    }\n    case 11: {\n      return \"fragment\";\n    }\n  }\n};\n\n/**\n * Determines the \"content-type\" of a given node\n */\nexport const getNodeType = (node: Container | HTML): NodeType => {\n  if (typeof node === \"string\") {\n    return \"html\";\n  }\n\n  const byType = nodeTypeLookup(node.nodeType);\n\n  if (byType) {\n    return byType;\n  }\n\n  return isTextNode(node)\n    ? \"text\"\n    : isElement(node)\n    ? \"element\"\n    : isDocument(node)\n    ? \"document\"\n    : isFragment(node)\n    ? \"fragment\"\n    : \"node\";\n};\n\n/**\n * A helper utility to help convert DOM nodes or HTML to common type.\n *\n * Start by providing the _exclusions_ you want to make for input. By default, all\n * `Container` types are allowed along with `HTML`\n */\nexport const solveForNodeType: NodeSolver = (_ = undefined as never) => {\n  const solver = <EE extends NodeType, OO>(): NodeSolverReceiver<EE, OO> => ({\n    solver: (s) => (node, parent) => {\n      if (node === null) {\n        throw new Error(\"Value passed into solver was NULL!\");\n      }\n      if (node === undefined) {\n        throw new Error(\"Value passed into solver was UNDEFINED!\");\n      }\n\n      const type = getNodeType(node);\n      if (type in s) {\n        const fn = (s as any)[type];\n        return fn(node, parent);\n      } else {\n        if (type === \"node\" && \"element\" in s && isElement(node)) {\n          const fn = (s as any).element;\n          return fn(node, parent);\n        } else if (type === \"node\" && \"text\" in s && isTextNode(node)) {\n          const fn = (s as any).text;\n          return fn(node);\n        }\n\n        throw new HappyMishap(`Problem finding \"${type}\" in solver.`, {\n          name: `solveForNodeType(${type})`,\n        });\n      }\n    },\n  });\n  return {\n    outputType: () => solver(),\n    mirror: () => solver(),\n  };\n};\n\n/**\n * Ensures any Container, array of Containers, or even HTML or HTML[] are all\n * normalized down to just HTML.\n */\nexport function toHtml<D extends ContainerOrHtml | ContainerOrHtml[] | null>(\n  node: D\n): HTML {\n  if (node === null) {\n    return \"\";\n  }\n\n  const n = (Array.isArray(node) ? node : [node]) as ContainerOrHtml[];\n  try {\n    const results = n.map((i) => {\n      const convert = solveForNodeType()\n        .outputType<HTML>()\n        .solver({\n          html: (h) => h,\n          text: (t) => t.textContent,\n          comment: (h) => `<!-- ${h.textContent} -->`,\n          element: (e) => e.outerHTML,\n          node: (ne) => {\n            if (isElement(ne)) {\n              convert(ne);\n            }\n            if (isTextNode(ne)) {\n              convert(ne);\n            }\n\n            throw new Error(\n              `Unknown node type detected while converting to HTML: [ name: ${ne.nodeName}, type: ${ne.nodeType}, value: ${ne.nodeValue} ]`\n            );\n          },\n          document: (d) =>\n            `<html>${d.head.hasChildNodes() ? d.head.outerHTML : \"\"}${\n              d.body.outerHTML\n            }</html>`,\n          fragment: (f) => {\n            return isElementLike(f)\n              ? f.firstElementChild.outerHTML\n              : f.childNodes.map((c) => convert(c, f)).join(\"\");\n          },\n        });\n\n      return convert(i);\n    });\n\n    return results.join(\"\");\n  } catch (error_) {\n    const error = Array.isArray(node)\n      ? new HappyMishap(\n          `Problem converting an array of ${n.length} nodes [${n\n            .map((i) => getNodeType(i as any))\n            .join(\", \")}] to HTML`,\n          {\n            name: \"toHTML([...])\",\n            inspect: [\"first node\", node[0]],\n            error: error_,\n          }\n        )\n      : new HappyMishap(`Problem converting \"${getNodeType(node)}\" to HTML!`, {\n          name: \"toHTML(getNodeType(node))\",\n          inspect: node,\n          error: error_,\n        });\n    throw error;\n  }\n}\n\n/**\n * Clones most DOM types\n */\nexport function clone<T extends Container | HTML>(container: T): T {\n  const clone = solveForNodeType()\n    .mirror()\n    .solver({\n      html: (h) => `${h}`,\n      fragment: flow(toHtml, createFragment),\n      document: (d) => {\n        return createDocument(d.body.innerHTML, d.head.innerHTML);\n      },\n      element: (e) => pipe(e, toHtml, createElement),\n      node: (n) => {\n        throw new HappyMishap(\"Can't clone an unknown node!\", { inspect: n });\n      },\n      text: flow(toHtml, createTextNode),\n      comment: flow(toHtml, createCommentNode),\n    });\n\n  return clone(container);\n}\n\n/**\n * ensures that a given string doesn't have any HTML inside of it\n */\nexport function safeString(str: string): string {\n  const node = createFragment(str);\n  return node.textContent;\n}\n","/* eslint-disable unicorn/prefer-logical-operator-over-ternary */\nimport { createElement, createFragment } from \"./create\";\nimport { describeNode, inspect } from \"./diagnostics\";\nimport { HappyMishap } from \"./errors\";\nimport type {\n  HTML,\n  NodeSelector,\n  UpdateCallback,\n  UpdateCallback_Native,\n} from \"./happy-types\";\nimport { getChildElements, wrap } from \"./nodes\";\nimport {\n  isDocument,\n  isElement,\n  isElementLike,\n  isFragment,\n  isHappyWrapperError,\n} from \"./type-guards\";\nimport { clone, getNodeType, toHtml } from \"./utils\";\nimport type { HappyDoc, Fragment, IElement, INode, IText } from \"./index\";\n\n/**\n * Allows the _selection_ of HTML or a container type which is\n * then wrapped and a helpful query and mutation API is provided\n * to work with this DOM element.\n */\nexport const select = <D extends HappyDoc | Fragment | IElement | HTML>(\n  node: D\n) => {\n  const originIsHtml = typeof node === \"string\";\n  let rootNode: HappyDoc | Fragment | IElement = originIsHtml\n    ? createFragment(node)\n    : isElement(node)\n    ? (node as IElement)\n    : isDocument(node) || isFragment(node)\n    ? node\n    : (undefined as never);\n\n  if (!rootNode) {\n    throw new HappyMishap(\n      `Attempt to select() an invalid node type: ${getNodeType(node)}`,\n      { name: \"select(INode)\", inspect: node }\n    );\n  }\n\n  type T = undefined extends D ? Fragment : D extends string ? \"html\" : D;\n  const api: NodeSelector<T> = {\n    type: () => {\n      return originIsHtml ? \"html\" : getNodeType(rootNode);\n    },\n\n    findAll: <S extends string | undefined>(sel: S) => {\n      return sel\n        ? (rootNode.querySelectorAll(sel) as IElement[])\n        : getChildElements(rootNode);\n    },\n\n    findFirst: <E extends string | undefined>(\n      sel: string,\n      errorMsg?: E\n    ): undefined extends E ? IElement | null : IElement => {\n      const result = rootNode.querySelector(sel) as IElement | null;\n      if (!result && errorMsg) {\n        throw new HappyMishap(\n          `${errorMsg}.\\n\\nThe HTML from the selected DOM node is:\\n${toHtml(\n            rootNode\n          )}`,\n          { name: \"select.findFirst()\", inspect: rootNode }\n        );\n      }\n\n      return result as undefined extends E ? IElement | null : IElement;\n    },\n\n    append: (\n      content:\n        | (IText | IElement | HTML | undefined)\n        | (IText | IElement | HTML | undefined)[]\n    ) => {\n      if (!content) {\n        return api;\n      }\n\n      const nodes = Array.isArray(content)\n        ? (content.filter(Boolean) as (INode | HTML)[])\n        : [content];\n      rootNode.append(...nodes);\n\n      return api;\n    },\n\n    /**\n     * Queries for the DOM node which matches the first DOM\n     * node within the DOM tree which was selected and provides\n     * a callback you can add to mutate this node.\n     *\n     * If no selector is provided, the root selection is used as the element\n     * to update.\n     *\n     * Note: by default if the query selection doesn't resolve any nodes then\n     * this is a no-op but you can optionally express that you'd like it to\n     * throw an error by setting \"errorIfFound\" to `true` or as a string if\n     * you want to state the error message.\n     */\n    update:\n      (selection?: string, errorIfNotFound: boolean | string = false) =>\n      <CB extends UpdateCallback>(mutate: CB): NodeSelector<T> => {\n        const el = selection\n          ? (rootNode?.querySelector(selection) as IElement | null)\n          : isElement(rootNode)\n          ? rootNode\n          : rootNode.firstElementChild\n          ? rootNode.firstElementChild\n          : null;\n\n        if (el) {\n          let elReplacement: IElement | false;\n          try {\n            elReplacement = (mutate as unknown as UpdateCallback_Native)(\n              el,\n              0,\n              1\n            );\n          } catch (error) {\n            throw new HappyMishap(\n              `update(): the passed in callback to select(container).update('${selection}')():  \\n\\n\\tmutate(${describeNode(\n                el\n              )}, 0, 1)\\n\\n${\n                error instanceof Error ? error.message : String(error)\n              }.`,\n              {\n                name: `select(${typeof rootNode}).updateAll(${selection})(mutation fn)`,\n                inspect: el,\n              }\n            );\n          }\n\n          if (elReplacement === false) {\n            el.remove();\n          } else if (!isElement(elReplacement)) {\n            throw new HappyMishap(\n              `The return value for a call to select(${getNodeType(\n                rootNode\n              )}).update(${selection}) return an invalid value! Value return values are an IElement or false.`,\n              { name: \"select.update\", inspect: el }\n            );\n          }\n        } else {\n          if (errorIfNotFound) {\n            throw new HappyMishap(\n              errorIfNotFound === true\n                ? `The selection \"${selection}\" was not found so the update() operation wasn't able to be run`\n                : errorIfNotFound,\n              {\n                name: `select(${selection}).update(sel)`,\n                inspect: [\"parent node\", rootNode],\n              }\n            );\n          }\n\n          if (!selection) {\n            throw new HappyMishap(\n              `Call to select(container).update() was intended to target the root node of the selection but nothing was selected! This shouldn\\'t really happen ... the rootNode\\'s type is ${typeof rootNode}${\n                typeof rootNode === \"object\"\n                  ? `, \n            ${getNodeType(rootNode)} [element-like: ${isElementLike(\n                      rootNode\n                    )}, element: ${isElement(rootNode)}, children: ${\n                      rootNode.childNodes.length\n                    }]`\n                  : \"\"\n              }`\n            );\n          }\n        }\n\n        return api;\n      },\n\n    /**\n     * mutate _all_ nodes with given selector; if no selector provided then\n     * all child nodes will be selected.\n     *\n     * Note: when passing in a selector you will get based on the DOM query but\n     * if nothing is passed in then you'll get the array of `IElement` nodes which\n     * are direct descendants of the root selector.\n     */\n    updateAll:\n      <S extends string | undefined>(selection?: S) =>\n      <CB extends UpdateCallback>(mutate: CB): NodeSelector<T> => {\n        /**\n         * The array of DOM nodes which have been selected.\n         */\n        const elements: IElement[] = (\n          selection\n            ? rootNode.querySelectorAll(selection)\n            : getChildElements(rootNode)\n        ) as IElement[];\n\n        for (const [idx, el] of elements.entries()) {\n          if (isElement(el)) {\n            let elReplacement: IElement | false;\n            try {\n              elReplacement = (mutate as unknown as UpdateCallback_Native)(\n                el,\n                idx,\n                elements.length\n              );\n            } catch (error) {\n              throw new HappyMishap(\n                `updateAll(): the passed in callback to select(container).updateAll('${selection}')():  \\n\\n\\tmutate(${describeNode(\n                  el\n                )}, ${idx} idx, ${elements.length} elements)\\n\\n${\n                  error instanceof Error ? error.message : String(error)\n                }.`,\n                {\n                  name: `select(${typeof rootNode}).updateAll(${selection})(mutation fn)`,\n                  inspect: el,\n                }\n              );\n            }\n            // an explicit `false` return indicates the intent to remove\n            if (elReplacement === false) {\n              el.remove();\n            } else if (!isElement(elReplacement)) {\n              // an element returned is the expected return but if not then throw an error\n              throw new HappyMishap(\n                `The return value from the \"select(container).updateAll('${selection}')(${describeNode(\n                  el\n                )}, ${idx} idx, ${\n                  elements.length\n                } elements)\" call was invalid! Valid return values are FALSE or an IElement but instead got: ${typeof elReplacement}.`,\n                { name: \"select().updateAll -> invalid return value\" }\n              );\n            }\n          } else {\n            throw new Error(\n              `Ran into an unknown node type while running updateAll(): ${JSON.stringify(\n                inspect(el),\n                null,\n                2\n              )}`\n            );\n          }\n        }\n\n        return api;\n      },\n\n    /**\n     * Maps over all IElement's which match the selection criteria (or all child\n     * elements if no selection provided) and provides a callback hook which allows\n     * a mutation to any data structure the caller wants.\n     *\n     * This method is non-destructive to the parent selection captured with the\n     * call to `select(dom)` and returns the map results to the caller instead of\n     * continuing the selection API surface.\n     */\n    mapAll: (selection) => (mutate) => {\n      const collection = [];\n      const elements: IElement[] = selection\n        ? rootNode.querySelectorAll(selection)\n        : getChildElements(rootNode);\n\n      for (const el of elements) {\n        collection.push(mutate(clone(el)));\n      }\n\n      return collection;\n    },\n\n    /**\n     * Filters out `IElement` nodes out of the selected DOM tree which match\n     * a particular DOM query. Also allows passing in an optional callback to\n     * receive elements which were filtered out\n     */\n    filterAll: <S extends string>(\n      selection: S,\n      cb?: (removed: IElement) => void\n    ) => {\n      for (const el of rootNode?.querySelectorAll(selection)) {\n        if (cb) {\n          cb(el);\n        }\n        el.remove();\n      }\n\n      return api;\n    },\n\n    wrap: (wrapper, errMsg) => {\n      try {\n        const safeWrap: IElement =\n          typeof wrapper === \"string\" ? createElement(wrapper) : wrapper;\n        rootNode = wrap(rootNode)(safeWrap);\n\n        return api;\n      } catch (error) {\n        if (isHappyWrapperError(error) || error instanceof Error) {\n          error.message = errMsg\n            ? `Error calling select.wrap(): ${errMsg}\\n${error.message}`\n            : `Error calling select.wrap():\\n${(error as Error).message}`;\n          throw error;\n        }\n\n        throw error;\n      }\n    },\n\n    toContainer: () => {\n      return (originIsHtml ? toHtml(rootNode) : rootNode) as undefined extends T\n        ? Fragment\n        : T extends \"html\"\n        ? string\n        : T;\n    },\n  };\n\n  return api;\n};\n"],"mappings":";AACA,SAAS,QAAAA,aAAY;;;ACArB,SAAS,gBAAgB;AACzB,SAAS,SAAS,MAAM,cAAc;AACtC,SAAS,iBAAiB;;;ACH1B,SAAS,gBAAgB;;;ACAV,SAAR,YAA6B;AACnC,QAAM,qBAAqB,MAAM;AACjC,QAAM,oBAAoB,CAAC,GAAGC,WAAUA;AACxC,QAAM,QAAQ,IAAI,MAAM,EAAE,MAAM,MAAM,CAAC;AACvC,QAAM,oBAAoB;AAC1B,SAAO;AACR;;;ACLA,SAAS,QAAAC,OAAM,QAAAC,aAAY;;;ACA3B,SAAS,QAAAC,aAAY;;;ACUd,SAAS,oBAAoB,KAAkC;AACpE,SAAO,OAAO,QAAQ,YAAa,IAAY,SAAS;AAC1D;AAEO,IAAM,oBAAoB,CAAC,UAA6C;AAC7E,SACE,MAAM,QAAQ,KAAK,KACnB,MAAM,WAAW,KACjB,OAAO,MAAM,OAAO,YACpB,CAAC,MAAM,QAAQ,MAAM,EAAE;AAE3B;AAEO,SAAS,WAAW,KAA+B;AACxD,SACE,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,UAAU,GAAG,KAAK,UAAU;AAE5E;AACO,SAAS,WAAW,KAA+B;AACxD,SACE,OAAO,QAAQ,YACf,QAAQ,QACR,CAAC,UAAU,GAAG,KACd,CAAC,WAAW,GAAG,KACf,EAAE,UAAU;AAEhB;AAEO,IAAM,wBAAwB,CAAoB,SAAY;AACnE,SAAO,CAAC,EAIL,KAAa,eAAgB,KAAa;AAE/C;AACO,IAAM,sBAAsB,CAAoB,SAAY;AACjE,SAAO,sBAAsB,QAAQ,KAAK,cAAc,KAAK;AAC/D;AAEO,IAAM,wBAAwB,CAAoB,SAAY;AACnE,SAAO,sBAAsB,IAAI,KAAK,oBAAoB,IAAI;AAChE;AAMO,IAAM,qBAAqB,CAAoB,SAAY;AAChE,SAAO,sBAAsB,IAAI,KAAK,KAAK,WAAW,WAAW;AACnE;AAEO,SAAS,UAAU,IAA6B;AACrD,SACE,OAAO,OAAO,YACd,OAAO,QACP,eAAgB,MACf,GAAW,aAAa;AAE7B;AAMO,IAAM,gBAAgB,CAAC,cAAuB;AACnD,MAAI,WAAW,SAAS,GAAG;AACzB,WACE,UAAU,KAAK,WAAW,WAAW,KACrC,UAAU,KAAK,eAAe,UAAU,KAAK;AAAA,EAEjD;AAEA,SACE,WAAW,SAAS,KACpB,UAAU,WAAW,WAAW,KAChC,UAAU,eAAe,UAAU;AAEvC;AAKO,SAAS,eAAe,MAAe;AA9F9C;AA+FE,UACG,WAAW,IAAI,KAAK,WAAW,IAAI,QACpC,kCAAM,eAAN,mBAAkB,YAAW,KAC7B,WAAW,KAAK,UAAU;AAE9B;AAMO,IAAM,oBAAoB,CAAC,SAA2C;AAC3E,SACE,MAAM,QAAQ,IAAI,KAClB,KAAK,WAAW,KAEhB,OAAO,KAAK,OAAO,YACnB,OAAO,KAAK,OAAO;AAEvB;AAEO,SAAS,WAAW,MAA8B;AACvD,MAAI,OAAO,SAAS,UAAU;AAC5B,UAAM,OAAO,eAAe,IAAI;AAChC,WAAO,eAAe,IAAI;AAAA,EAC5B,OAAO;AACL,WACE,OAAO,SAAS,YAChB,SAAS,QACT,EAAE,uBAAwB;AAAA,EAE9B;AACF;AAEO,IAAM,cAAc,CAAC,UAAuC;AACjE,SACE,WAAW,KAAK,KAChB,WAAW,KAAK,KAChB,UAAU,KAAK,KACf,WAAW,KAAK;AAEpB;AAKO,IAAM,0BAA0B,CAAoB,SAAY;AACrE,SAAO,KAAK,WAAW,MAAM,CAAC,MAAM,UAAU,CAAC,CAAC;AAClD;;;AC/IA,SAAS,MAAM,YAAY;AA6BpB,IAAM,iBAAiB,CAAC,SAAuC;AACpE,UAAQ,MAAM;AAAA,IACZ,KAAK,GAAG;AACN,aAAO;AAAA,IACT;AAAA,IACA,KAAK,GAAG;AACN,aAAO;AAAA,IACT;AAAA,IACA,KAAK,GAAG;AACN,aAAO;AAAA,IACT;AAAA,IACA,KAAK,IAAI;AACP,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAKO,IAAM,cAAc,CAAC,SAAqC;AAC/D,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,eAAe,KAAK,QAAQ;AAE3C,MAAI,QAAQ;AACV,WAAO;AAAA,EACT;AAEA,SAAO,WAAW,IAAI,IAClB,SACA,UAAU,IAAI,IACd,YACA,WAAW,IAAI,IACf,aACA,WAAW,IAAI,IACf,aACA;AACN;AAQO,IAAM,mBAA+B,CAAC,IAAI,WAAuB;AACtE,QAAM,SAAS,OAA4D;AAAA,IACzE,QAAQ,CAAC,MAAM,CAAC,MAAM,WAAW;AAC/B,UAAI,SAAS,MAAM;AACjB,cAAM,IAAI,MAAM,oCAAoC;AAAA,MACtD;AACA,UAAI,SAAS,QAAW;AACtB,cAAM,IAAI,MAAM,yCAAyC;AAAA,MAC3D;AAEA,YAAM,OAAO,YAAY,IAAI;AAC7B,UAAI,QAAQ,GAAG;AACb,cAAM,KAAM,EAAU;AACtB,eAAO,GAAG,MAAM,MAAM;AAAA,MACxB,OAAO;AACL,YAAI,SAAS,UAAU,aAAa,KAAK,UAAU,IAAI,GAAG;AACxD,gBAAM,KAAM,EAAU;AACtB,iBAAO,GAAG,MAAM,MAAM;AAAA,QACxB,WAAW,SAAS,UAAU,UAAU,KAAK,WAAW,IAAI,GAAG;AAC7D,gBAAM,KAAM,EAAU;AACtB,iBAAO,GAAG,IAAI;AAAA,QAChB;AAEA,cAAM,IAAI,YAAY,oBAAoB,oBAAoB;AAAA,UAC5D,MAAM,oBAAoB;AAAA,QAC5B,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL,YAAY,MAAM,OAAO;AAAA,IACzB,QAAQ,MAAM,OAAO;AAAA,EACvB;AACF;AAMO,SAAS,OACd,MACM;AACN,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,EACT;AAEA,QAAM,IAAK,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC,IAAI;AAC7C,MAAI;AACF,UAAM,UAAU,EAAE,IAAI,CAAC,MAAM;AAC3B,YAAM,UAAU,iBAAiB,EAC9B,WAAiB,EACjB,OAAO;AAAA,QACN,MAAM,CAAC,MAAM;AAAA,QACb,MAAM,CAAC,MAAM,EAAE;AAAA,QACf,SAAS,CAAC,MAAM,QAAQ,EAAE;AAAA,QAC1B,SAAS,CAAC,MAAM,EAAE;AAAA,QAClB,MAAM,CAAC,OAAO;AACZ,cAAI,UAAU,EAAE,GAAG;AACjB,oBAAQ,EAAE;AAAA,UACZ;AACA,cAAI,WAAW,EAAE,GAAG;AAClB,oBAAQ,EAAE;AAAA,UACZ;AAEA,gBAAM,IAAI;AAAA,YACR,gEAAgE,GAAG,mBAAmB,GAAG,oBAAoB,GAAG;AAAA,UAClH;AAAA,QACF;AAAA,QACA,UAAU,CAAC,MACT,SAAS,EAAE,KAAK,cAAc,IAAI,EAAE,KAAK,YAAY,KACnD,EAAE,KAAK;AAAA,QAEX,UAAU,CAAC,MAAM;AACf,iBAAO,cAAc,CAAC,IAClB,EAAE,kBAAkB,YACpB,EAAE,WAAW,IAAI,CAAC,MAAM,QAAQ,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE;AAAA,QACpD;AAAA,MACF,CAAC;AAEH,aAAO,QAAQ,CAAC;AAAA,IAClB,CAAC;AAED,WAAO,QAAQ,KAAK,EAAE;AAAA,EACxB,SAAS,QAAP;AACA,UAAM,QAAQ,MAAM,QAAQ,IAAI,IAC5B,IAAI;AAAA,MACF,kCAAkC,EAAE,iBAAiB,EAClD,IAAI,CAAC,MAAM,YAAY,CAAQ,CAAC,EAChC,KAAK,IAAI;AAAA,MACZ;AAAA,QACE,MAAM;AAAA,QACN,SAAS,CAAC,cAAc,KAAK,EAAE;AAAA,QAC/B,OAAO;AAAA,MACT;AAAA,IACF,IACA,IAAI,YAAY,uBAAuB,YAAY,IAAI,eAAe;AAAA,MACpE,MAAM;AAAA,MACN,SAAS;AAAA,MACT,OAAO;AAAA,IACT,CAAC;AACL,UAAM;AAAA,EACR;AACF;AAKO,SAAS,MAAkC,WAAiB;AACjE,QAAMC,SAAQ,iBAAiB,EAC5B,OAAO,EACP,OAAO;AAAA,IACN,MAAM,CAAC,MAAM,GAAG;AAAA,IAChB,UAAU,KAAK,QAAQ,cAAc;AAAA,IACrC,UAAU,CAAC,MAAM;AACf,aAAO,eAAe,EAAE,KAAK,WAAW,EAAE,KAAK,SAAS;AAAA,IAC1D;AAAA,IACA,SAAS,CAAC,MAAM,KAAK,GAAG,QAAQ,aAAa;AAAA,IAC7C,MAAM,CAAC,MAAM;AACX,YAAM,IAAI,YAAY,gCAAgC,EAAE,SAAS,EAAE,CAAC;AAAA,IACtE;AAAA,IACA,MAAM,KAAK,QAAQ,cAAc;AAAA,IACjC,SAAS,KAAK,QAAQ,iBAAiB;AAAA,EACzC,CAAC;AAEH,SAAOA,OAAM,SAAS;AACxB;AAKO,SAAS,WAAW,KAAqB;AAC9C,QAAM,OAAO,eAAe,GAAG;AAC/B,SAAO,KAAK;AACd;;;AF5KO,IAAM,cAAc,CAAC,OAAwC;AAClE,MAAI,CAAC,GAAG,cAAc,GAAG;AACvB,WAAO,CAAC;AAAA,EACV;AAEA,QAAM,SAA+B,CAAC;AACtC,MAAI,QAAQ,GAAG;AAEf,WAAS,MAAM,GAAG,MAAM,GAAG,WAAW,QAAQ,OAAO;AACnD,QAAI,UAAU,KAAK,KAAK,WAAW,KAAK,GAAG;AACzC,aAAO,KAAK,KAAK;AAAA,IACnB,WAAW,WAAW,KAAK,KAAK,WAAW,KAAK,GAAG;AACjD,iBAAW,aAAa,YAAY,KAAK,GAAG;AAC1C,eAAO,KAAK,SAAS;AAAA,MACvB;AAAA,IACF,OAAO;AACL,YAAM,IAAI;AAAA,QACR,sBAAsB;AAAA,UACpB;AAAA,QACF;AAAA,QACA,EAAE,MAAM,sBAAsB,SAAS,MAAM;AAAA,MAC/C;AAAA,IACF;AAEA,YAAQ,MAAM;AAAA,EAChB;AAEA,SAAO;AACT;AAEO,IAAM,mBAAmB,CAAC,OAA8B;AAC7D,SAAO,YAAY,EAAE,EAAE,OAAO,CAAC,MAAM,UAAU,CAAC,CAAC;AACnD;AAaO,IAAM,UACX,CAAsD,WACtD,CACE,SACU;AACV,MAAI,QAAQ;AACV,WAAO,KAAK,MAAM,IAAI,CAAU;AAAA,EAClC;AACA,SAAO;AACT;AAkBK,IAAM,cACX,CACE,QACAC,iBAEF,CAAqB,SAAsB;AACzC,MAAI,QAAQ;AACV,WAAO,KAAK,MAAM,IAAI,CAAU;AAAA,EAClC;AACA,QAAM,KAAKA,eACPA,eACA,cAAc,6BAA6B;AAC/C,WAAS,GAAG,aAAa,IAAI,CAAC,EAAE,EAAE;AAClC,OAAK,YAAY,EAAE;AAEnB,SAAO;AACT;AAMK,IAAM,iBACX,CAAC,eACD,CAAC,eAAmC;AAClC,QAAM,SAAS,WAAW;AAC1B,MAAI,UAAU,MAAM,KAAK,WAAW,MAAM,GAAG;AAC3C,WAAO,aAAa,cAAc,UAAU,GAAG,UAAU;AAAA,EAC3D;AAEA,QAAM,QACJ,OAAO,eAAe,WAAW,cAAc,UAAU,IAAI;AAE/D,MAAI,QAAQ;AACV,UAAM,WAAW,iBAAiB,MAAM;AACxC,UAAM,WAAW,SAAS;AAAA,MACxB,CAAC,MAAM,OAAO,CAAC,MAAM,OAAO,UAAU;AAAA,IACxC;AAEA,UAAM,WAAuB,YAAY,CAAC,GAAG;AAAA,MAAI,CAAC,GAAG,MACnD,MAAM,WAAW,QAAQ;AAAA,IAC3B;AACA,WAAO,gBAAgB,GAAG,OAAO;AAAA,EACnC;AACA,SAAO;AACT;AAKK,IAAM,SAAS,IAAiC,UAAmB;AACxE,QAAM,IAAI,MAAM,KAAK;AACrB,SAAO,CACL,WACwC;AACxC,UAAM,SAAS,iBAAiB,QAAQ,QAAQ,SAAS,EACtD,OAAO,EACP,OAAO;AAAA,MACN,MAAM,CAAC,MAAMC,MAAK,GAAG,eAAe,OAAO,GAAG,KAAK,GAAG,MAAM;AAAA,MAC5D,SAAS,CAAC,MAAM;AACd,mBAAW,KAAK,GAAG;AACjB,YAAE,OAAO,CAAC;AAAA,QACZ;AACA,eAAO;AAAA,MACT;AAAA,MACA,UAAU,CAAC,MAAM;AACf,mBAAW,KAAK,GAAG;AACjB,YAAE,OAAO,CAAC;AAAA,QACZ;AACA,eAAO;AAAA,MACT;AAAA,MACA,UAAU,CAAC,MAAM;AACf,mBAAW,KAAK,GAAG;AACjB,YAAE,KAAK,OAAO,CAAC;AAAA,QACjB;AACA,eAAO;AAAA,MACT;AAAA,IACF,CAAC,EAAE,kBAAkB,MAAM,IAAI,OAAO,KAAK,MAAM;AAEnD,WAAO;AAAA,EACT;AACF;AAgCO,IAAM,OACX,CAEE,WAEF,IACK,YAKI;AAKP,QAAM,UAAU,CAAC,EAAE,OAAO,WAAW;AAOrC,MAAI,mBAAuC,UACvC,eAAe,MAAM,IACrB,UAAU,MAAM,IAChB,SACA,SACA,SACA,eAAe;AAGnB,QAAM,OAAO,kBAAkB,OAAO,IAClC,CAAC,QAAQ,EAAE,IACX,QAAQ,QAAQ,CAAC,MAAM,CAAuB;AAElD,MAAI,eAAe,gBAAgB,GAAG;AACpC,UAAM,IAAI;AAAA,MACR,0GAA0G;AAAA,QACxG;AAAA,MACF;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,SAAS,CAAC,CAAC,eAAe,MAAM,CAAC;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,cAAc,KAAK,IAAI,CAAC,MAAM,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE;AACtD,QAAM,YAAY,eAAe,WAAW;AAC5C,QAAM,yBAAyB,iBAAiB,oBAAoB;AAEpE,MAAI,wBAAwB;AAC1B,eAAW,KAAK,YAAY,SAAS,GAAG;AAEtC,uBAAiB,WAAW,YAAY,MAAM,CAAC,CAAC;AAAA,IAClD;AAAA,EACF,OAAO;AACL,eAAW,KAAK,YAAY,SAAS,GAAG;AACtC,uBAAiB,OAAO,CAAC;AAAA,IAC3B;AAAA,EACF;AAKA,MAAI,kBAAkB,OAAO,KAAK,UAAU,QAAQ,EAAE,GAAG;AACvD,uBAAmB,cAAc,gBAAgB,IAC7C,iBAAiB,oBACjB,cAAc,gBAAgB;AAElC,YAAQ,GAAG,YAAY,gBAAgB;AAAA,EACzC;AAEA,SACE,WAAW,CAAC,kBAAkB,OAAO,IACjC,OAAO,gBAAgB,IACvB;AAMR;AAiBK,IAAM,gBACX,CAAmB,YACnB,IACK,SAC0C;AAC7C,QAAM,OAAO,KAAK;AAElB,QAAM,WAAW,CAAC,IAAcC,aAAoB;AAClD,UAAM,OAAO,IAAI,OAAO,KAAK,GAAG,QAAQ,YAAY,GAAG;AACvD,UAAM,QAAQ,IAAI,OAAO,KAAM,GAAG,QAAQ,YAAY,KAAK;AAE3D,UAAM,SAAS,OAAO,EAAE,EACrB,QAAQ,MAAM,IAAIA,UAAS,EAC3B,QAAQ,OAAO,KAAKA,WAAU;AACjC,QAAI,GAAG,cAAc,GAAG,eAAe,MAAM;AAC3C,SAAG,WAAW,aAAa,WAAW,MAAM,GAAG,EAAE;AAAA,IACnD;AAEA,WAAO;AAAA,EACT;AAGA,QAAM,aAAa,CAACC,SAAgBC,WAClCD,QAAO,kBAAkB,MAAMC,OAAM,kBAAkB;AAEzD,SAAO,iBAAiB,EACrB,OAAO,EACP,OAAO;AAAA,IACN,MAAM,CAAC,MAAM;AACX,YAAMD,UAAS,eAAe,CAAC,EAAE,kBAAkB;AACnD,aAAO,WAAWA,SAAQ,OAAO,IAC7B,IACA,OAAO,SAAS,eAAe,CAAC,EAAE,mBAAmB,OAAO,CAAC;AAAA,IACnE;AAAA,IACA,MAAM,CAAC,MAAM;AACX,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,SAAS,GAAG,MAAM,uBAAuB;AAAA,MAC7C;AAAA,IACF;AAAA,IACA,SAAS,CAAC,MAAM;AACd,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,SAAS,GAAG,MAAM,0BAA0B;AAAA,MAChD;AAAA,IACF;AAAA,IACA,MAAM,CAAC,MAAM;AACX,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,SAAS,GAAG,MAAM,uBAAuB;AAAA,MAC7C;AAAA,IACF;AAAA,IACA,SAAS,CAAC,OACR,WAAW,GAAG,SAAS,OAAO,IAC1B,KACA,eAAe,SAAS,IAAI,OAAO,CAAC,EAAE,EAAE;AAAA,IAE9C,UAAU,CAAC,MAAM;AACf,UAAI,EAAE,mBAAmB;AACvB,YAAI,EAAE,kBAAkB,eAAe;AACrC,YAAE,kBAAkB;AAAA,YAClB,cAAc,OAAO,EAAE,EAAE,iBAAiB;AAAA,UAC5C;AAAA,QACF,OAAO;AACL,gBAAM,IAAI;AAAA,YACR;AAAA,YACA,EAAE,MAAM,2BAA2B,SAAS,EAAE;AAAA,UAChD;AAAA,QACF;AAAA,MACF,OAAO;AACL,cAAM,IAAI;AAAA,UACR;AAAA,UACA,EAAE,MAAM,2BAA2B,SAAS,EAAE;AAAA,QAChD;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,IACA,UAAU,CAAC,MAAM;AACf,QAAE,KAAK,kBAAkB;AAAA,QACvB,cAAc,OAAO,EAAE,EAAE,KAAK,iBAAiB;AAAA,MACjD;AACA,YAAM,OAAO,OAAO,EAAE,IAAI;AAC1B,YAAM,OAAO,EAAE,KAAK;AAEpB,aAAO,eAAe,MAAM,IAAI;AAAA,IAClC;AAAA,EACF,CAAC,EAAE,IAAI;AACX;AAWK,IAAM,UACX,CAACE,aACD,CAAC,OAA2B;AAC1B,QAAM,IACJ,OAAOA,aAAY,WACf,eAAeA,QAAO,EAAE,aACxBA;AAEN,KAAG,QAAQ,CAAC;AACZ,SAAO;AACT;AAmBK,IAAM,SACX,CAA4B,eAC5B,IACK,cACsE;AACzE,QAAM,eAAe,OAAO,UAAU,OAAO;AAC7C,QAAM,mBACJ,OAAO,eAAe,WAChB,eAAe,UAAU,EAAE,qBAC3B,eAAe,UAAU,EAAE,aAC7B,WAAW,UAAU;AAE3B,QAAM,kBACJ,OAAO,UAAU,OAAO,WACpB,eAAe,UAAU,EAAE,IAC3B,kBAAkB,UAAU,EAAE,IAC9B,UAAU,GAAG,KACb,UAAU;AAEhB,QAAM,cAAc,CAAC,MAA0B;AAC7C,UAAM,IAAI;AAAA,MACR,mFAAmF;AAAA,QACjF;AAAA,MACF;AAAA,MACA;AAAA,QACE,MAAM,UAAU,YAAY,gBAAgB,MAAM,YAAY,CAAC;AAAA,QAC/D,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AAEA,QAAM,WAAW,CAAC,MAChB,IAAI;AAAA,IACF;AAAA,IACA;AAAA,MACE,MAAM,UAAU,YAAY,UAAU,MAAM,YAAY,CAAC;AAAA,IAC3D;AAAA,EACF;AAEF,QAAM,OAAO,iBAAiB,EAC3B,OAAO,EACP,OAAO;AAAA,IACN,MAAM,CAAC,MAAMJ,MAAK,GAAG,gBAAgB,OAAO,UAAU,GAAG,MAAM;AAAA,IAC/D,MAAM,CAAC,MAAM;AACX,UAAI,CAAC,EAAE,eAAe;AACpB,cAAM,SAAS,CAAC;AAAA,MAClB;AACA,QAAE,OAAO,gBAAgB;AACzB,aAAO;AAAA,IACT;AAAA,IACA,SAAS,CAAC,MAAM;AACd,UAAI,CAAC,EAAE,eAAe;AACpB,cAAM,SAAS,CAAC;AAAA,MAClB;AACA,QAAE,OAAO,gBAAgB;AACzB,aAAO;AAAA,IACT;AAAA,IACA,MAAM,CAAC,MAAM,YAAY,CAAC;AAAA,IAC1B,UAAU,CAAC,MAAM;AACf,QAAE,KAAK,QAAQ,gBAAgB;AAC/B,aAAO;AAAA,IACT;AAAA,IACA,UAAU,CAAC,MAAM;AACf,QAAE,QAAQ,gBAAgB;AAC1B,aAAO;AAAA,IACT;AAAA,IACA,SAAS,CAAC,OAAO;AACf,UAAI,GAAG,eAAe;AAEpB,WAAG,OAAO,gBAAgB;AAE1B,eAAO;AAAA,MACT,OAAO;AACL,cAAM,SAAS,EAAE;AAAA,MACnB;AAAA,IACF;AAAA,EACF,CAAC,EAAE,eAAe;AAEpB,SACE,gBAAgB,CAAC,kBAAkB,SAAS,IAAI,OAAO,IAAI,IAAI;AAEnE;AAEK,IAAM,QACX,CAAC,cACD,CAAuC,eAAqB;AAC1D,QAAM,kBACJ,OAAO,cAAc,WACjB,eAAe,SAAS,EAAE,oBAC1B;AAEN,QAAM,cAAc,CAAC,MAA0B;AAC7C,UAAM,IAAI;AAAA,MACR,4DAA4D;AAAA,QAC1D;AAAA,MACF;AAAA,MACA,EAAE,MAAM,SAAS,YAAY,UAAU,cAAc;AAAA,IACvD;AAAA,EACF;AAEA,SAAO,iBAAiB,EACrB,OAAO,EACP,OAAO;AAAA,IACN,MAAM,CAAC,MAAMA,MAAK,GAAG,gBAAgB,MAAM,SAAS,GAAG,MAAM;AAAA,IAC7D,MAAM,CAAC,MAAM,YAAY,CAAC;AAAA,IAC1B,SAAS,CAAC,MAAM,YAAY,CAAC;AAAA,IAC7B,MAAM,CAAC,MAAM,YAAY,CAAC;AAAA,IAC1B,UAAU,CAAC,MAAM;AACf,QAAE,KAAK,OAAO,eAAe;AAC7B,aAAO;AAAA,IACT;AAAA,IACA,UAAU,CAAC,MAAM;AACf,QAAE,OAAO,eAAe;AACxB,aAAO;AAAA,IACT;AAAA,IACA,SAAS,CAAC,OAAO;AACf,UAAI,GAAG,eAAe;AAEpB,WAAG,MAAM,eAAe;AAExB,eAAO;AAAA,MACT,OAAO;AACL,cAAM,IAAI;AAAA,UACR;AAAA,UACA,EAAE,MAAM,SAAS,YAAY,SAAS,eAAe;AAAA,QACvD;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC,EAAE,UAAU;AACjB;AAyBK,IAAM,OACX,IACK,aAEL,CAAkD,WAAe;AAC/D,SAAO,KAAK,MAAM,EAAE,GAAG,QAAQ;AACjC;;;AD1kBF,SAAS,UAAU,GAAc;AAC/B,QAAM,OAAO,aAAa,CAAC;AAC3B,SAAO,KAAK,SAAS,IAAI,KAAK,KAAK,KAAK,GAAG,QAAQ;AACrD;AAEA,SAAS,SAAS,GAAa;AAE7B,QAAM,WAAW,YAAY,CAAC,EAAE,IAAI,CAAC,MAAM,aAAa,CAAC,CAAC;AAC1D,SAAO,cAAc,CAAC,IAClB,QAAQ,EAAE,kBAAkB,QAAQ,YAAY,KAAK,cACrD,eAAe,CAAC,IAChB,UAAU,EAAE,YAAY,MAAM,GAAG,CAAC,EAAE,QAAQ,QAAQ,EAAE,UACtD,cAAc,SAAS,SAAS,IAAI,GAAG,SAAS,KAAK,IAAI,MAAM;AACrE;AAEO,IAAM,eAAe,CAC1B,SACW;AACX,MAAI,CAAC,MAAM;AACT,WAAO,SAAS,OAAO,WAAW;AAAA,EACpC,WAAW,kBAAkB,IAAI,GAAG;AAClC,WAAO,mBAAmB,aAAa,KAAK,EAAE;AAAA,EAChD,WAAW,MAAM,QAAQ,IAAI,GAAG;AAC9B,WAAO,KAAK,IAAI,CAAC,MAAM,aAAa,CAAC,CAAC,EAAE,KAAK,IAAI;AAAA,EACnD;AAEA,SAAO,iBAAiB,EACrB,WAAmB,EACnB,OAAO;AAAA,IACN,MAAM,CAAC,MAAMK,MAAK,GAAG,gBAAgB,YAAY;AAAA,IACjD,MAAM,CAAC,MAAM,OAAO,UAAU,CAAC;AAAA,IAC/B,MAAM,CAAC,MAAM,QAAQ,EAAE,YAAY,MAAM,GAAG,CAAC,EAAE,QAAQ,MAAM,EAAE;AAAA,IAC/D,SAAS,CAAC,MACR,WAAW,EAAE,YAAY,MAAM,GAAG,CAAC,EAAE,QAAQ,MAAM,EAAE;AAAA,IACvD,SAAS,CAAC,MAAM,WAAW,EAAE,QAAQ,YAAY,KAAK,UAAU,CAAC;AAAA,IACjE,UAAU,CAAC,MAAM,WAAW,SAAS,CAAC;AAAA,IACtC,UAAU,CAAC,MACT,aAAa,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,EAAE,UAAU;AAAA,MAC5C,eAAe,EAAE,IAAI;AAAA,IACvB;AAAA,EACJ,CAAC,EAAE,IAAI;AACX;AAEO,IAAM,UAAU,CACrB,MACA,SAAY,UACuC;AACnD,QAAM,SAAS,MAAM,QAAQ,IAAI,IAC7B,MAAM,KAAK,IAAI,CAAC,MAAM,aAAa,CAAC,CAAC,IACrC,iBAAiB,EACd,WAAgC,EAChC,OAAO;AAAA,IACN,MAAM,CAAC,MAAMA,MAAK,GAAG,gBAAgB,CAAC,MAAM,QAAQ,CAAC,CAAC;AAAA,IACtD,UAAU,CAAC,OAAO;AAAA,MAChB,MAAM;AAAA,MACN,UAAU,GAAG,EAAE,SAAS,YAAY,EAAE,WAAW;AAAA,MACjD,GAAI,EAAE,WAAW,SAAS,IACtB;AAAA,QACE,WAAW,UAAU,EAAE,UAAU,IAC7B,YACA,WAAW,EAAE,UAAU,IACvB,SACA;AAAA,QACJ,UAAU,UAAU,EAAE,SAAS,IAC3B,YACA,WAAW,EAAE,SAAS,IACtB,SACA;AAAA,MACN,IACA;AAAA,QACE,WAAW,QAAQ,EAAE,UAAU;AAAA,MACjC;AAAA,MACJ,SACE,EAAE,YAAY,SAAS,MACnB,GAAG,EAAE,YAAY,MAAM,GAAG,GAAG,UAC7B,EAAE;AAAA,MACR,cAAc,EAAE,WAAW,IAAI,CAAC,MAAM;AACpC,YAAI;AACF,iBAAO;AAAA,YACL,MAAM,OAAO,CAAC;AAAA,YACd,UAAU,YAAY,CAAC;AAAA,YACvB,kBAAkB,CAAC,CAAC,EAAE;AAAA,YACtB,eAAe,EAAE,aACb,GAAG,YAAY,EAAE,UAAU,WACzB,EAAE,WAAW,cAEf;AAAA,YACJ,YAAY,EAAE,WAAW;AAAA,UAC3B;AAAA,QACF,QAAE;AACA,iBAAO;AAAA,QACT;AAAA,MACF,CAAC;AAAA,MACD,MAAM,OAAO,CAAC;AAAA,IAChB;AAAA,IACA,UAAU,CAAC,MAAG;AAxHxB;AAwH4B;AAAA,QAChB,MAAM;AAAA,QACN,iBAAgB,OAAE,KAAK,eAAP,mBAAmB;AAAA,QACnC,eAAc,OAAE,KAAK,eAAP,mBAAmB;AAAA,QACjC,MAAM,OAAO,EAAE,IAAI;AAAA,QACnB,UAAU,IAAG,OAAE,KAAK,aAAP,mBAAiB,aAAY,OAAE,KAAK,eAAP,mBAAmB;AAAA,QAC7D,kBAAkB,EAAE,KAAK,WAAW,IAAI,CAAC,MAAM,EAAE,WAAW;AAAA,QAC5D,cAAc,EAAE,WAAW,IAAI,CAAC,MAAM;AACpC,cAAI;AACF,mBAAO;AAAA,cACL,MAAM,OAAO,CAAC;AAAA,cACd,UAAU,YAAY,CAAC;AAAA,cACvB,kBAAkB,CAAC,CAAC,EAAE;AAAA,cACtB,eAAe,EAAE,aACb,GAAG,YAAY,EAAE,UAAU,WACzB,EAAE,WAAW,cAEf;AAAA,cACJ,YAAY,EAAE,WAAW;AAAA,YAC3B;AAAA,UACF,QAAE;AACA,mBAAO;AAAA,UACT;AAAA,QACF,CAAC;AAAA,MACH;AAAA;AAAA,IACA,MAAM,CAAC,MAAG;AAjJpB;AAiJwB;AAAA,QACZ,MAAM;AAAA,QACN,aACE,EAAE,YAAY,SAAS,MACnB,GAAG,EAAE,YAAY,MAAM,GAAG,GAAG,UAC7B,EAAE;AAAA,QACR,WAAU,OAAE,eAAF,mBAAc;AAAA,QACxB,eAAc,OAAE,eAAF,mBAAc,IAAI,CAAC,MAAM,EAAE;AAAA,MAC3C;AAAA;AAAA,IACA,SAAS,CAAC,MAAG;AA1JvB;AA0J2B;AAAA,QACf,MAAM;AAAA,QACN,aACE,EAAE,YAAY,SAAS,MACnB,GAAG,EAAE,YAAY,MAAM,GAAG,GAAG,UAC7B,EAAE;AAAA,QACR,WAAU,OAAE,eAAF,mBAAc;AAAA,QACxB,eAAc,OAAE,eAAF,mBAAc,IAAI,CAAC,MAAM,EAAE;AAAA,MAC3C;AAAA;AAAA,IACA,SAAS,CAAC,MAAG;AAnKvB;AAmK2B;AAAA,QACf,MAAM;AAAA,QACN,SAAS,EAAE;AAAA,QACX,SAAS,aAAa,CAAC;AAAA,QAMvB,kBAAkB,CAAC,CAAC,EAAE;AAAA,QACtB,GAAI,EAAE,gBACF,EAAE,QAAQ,aAAa,EAAE,aAAa,EAAE,IACxC,CAAC;AAAA,QACL,aAAa,EAAE;AAAA,QACf,UAAU,GAAG,EAAE,SAAS,YAAY,EAAE,WAAW;AAAA,QACjD,eAAc,OAAE,eAAF,mBAAc,IAAI,CAAC,MAAM,EAAE;AAAA,QACzC,cAAc,EAAE,WAAW,IAAI,CAAC,MAAM;AACpC,cAAI;AACF,mBAAO;AAAA,cACL,MAAM,OAAO,CAAC;AAAA,cACd,UAAU,YAAY,CAAC;AAAA,cACvB,kBAAkB,CAAC,CAAC,EAAE;AAAA,cACtB,eAAe,EAAE,aACb,GAAG,YAAY,EAAE,UAAU,WACzB,EAAE,WAAW,cAEf;AAAA,cACJ,YAAY,EAAE,WAAW;AAAA,YAC3B;AAAA,UACF,QAAE;AACA,mBAAO;AAAA,UACT;AAAA,QACF,CAAC;AAAA,QACD,MAAM,SAAS,GAAG,EAAE,OAAO,CAAC,CAAC;AAAA,MAC/B;AAAA;AAAA,IACA,MAAM,CAAC,MAAG;AAtMpB;AAsMwB;AAAA,QACZ,MAAM;AAAA,QACN,WAAW,UAAU,CAAC,IAClB,YACA,WAAW,CAAC,IACZ,SACA;AAAA,QACJ,UAAU,IAAG,OAAE,eAAF,mBAAc;AAAA,QAC3B,eAAc,OAAE,eAAF,mBAAc,IAAI,CAAC,MAAM,SAAS,GAAG,EAAE,EAAE,WAAW;AAAA,QAClE,MAAM,SAAS,GAAG,EAAE,EAAE,SAAS,CAAC;AAAA,MAClC;AAAA;AAAA,EACF,CAAC;AACP,QAAM,SACJ,YAAY,IAAI,KAAK,OAAO,SAAS,WACjC,OAAO,IAAI,IACX;AAAA,IACE,QAAQ;AAAA,IACR,MAAM,OAAO;AAAA,IACb,GAAI,OAAO,SAAS,YAAY,SAAS,OACrC,EAAE,MAAM,OAAO,KAAK,IAAc,EAAE,IACpC,EAAE,OAAO,KAAK,UAAU,IAAI,EAAE;AAAA,EACpC;AACN,SAAQ,SAAS,KAAK,UAAU,QAAQ,MAAM,CAAC,IAAI;AAGrD;AAEA,IAAM,qBAAqB,CAAC,UAC1B,MAAM,QAAQ,QAAQ,EAAE,EAAE,QAAQ,QAAQ,EAAE,EAAE,KAAK;AACrD,IAAM,WAAW,CAAC,cAAsB,CAAC,UACvC,MAAM,MAAM,GAAG,SAAS;AAEnB,IAAM,OAAO,CAAC,SAAiC;AACpD,QAAM,YAAY,CAACC,UAAsC;AACvD,UAAM,UAAU,CAAC,MAA0C;AACzD,UAAI;AACJ,cAAQ,EAAE,MAAM;AAAA,QACd,KAAK,QAAQ;AACX,eAAK;AAAA,YACH,MAAM,KAAKD;AAAA,cACT,EAAE,KAAK;AAAA,cACP;AAAA,cACA,SAAS,EAAE;AAAA,YACb;AAAA,YACA,UAAU,EAAE,SAAS,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC;AAAA,UAC5C;AACA;AAAA,QACF;AAAA,QACA,KAAK,WAAW;AACd,eAAK;AAAA,YACH,MAAM,KAAKA;AAAA,cACT,EAAE,KAAK;AAAA,cACP;AAAA,cACA,SAAS,EAAE;AAAA,YACb;AAAA,YACA,UAAU,EAAE,SAAS,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC;AAAA,UAC5C;AACA;AAAA,QACF;AAAA,QACA,KAAK,WAAW;AACd,gBAAM,KAAK,EAAE;AACb,eAAK;AAAA,YACH,MAAM,MAAM,GAAG,QAAQ,YAAY;AAAA,YACnC,UAAU,EAAE,SAAS,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC;AAAA,UAC5C;AACA;AAAA,QACF;AAAA,QACA,KAAK,QAAQ;AACX,gBAAME,QAAO,EAAE;AACf,eAAK;AAAA,YACH,MAAM,KACJF,MAAKE,MAAK,UAAU,oBAAoB,SAAS,EAAE,CAAC,KACpDF,MAAKE,MAAK,aAAa,oBAAoB,SAAS,EAAE,CAAC;AAAA,YAEzD,UAAU,EAAE,SAAS,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC;AAAA,UAC5C;AACA;AAAA,QACF;AAAA,QACA,KAAK,YAAY;AACf,gBAAM,IAAI,EAAE;AACZ,eAAK;AAAA,YACH,MAAM,QACJ,EAAE,oBACE,EAAE,kBAAkB,QAAQ,YAAY,IACxC,mBAAmB,EAAE,WAAW,EAAE,KAAK,EAAE,MAAM,GAAG,EAAE;AAAA,YAE1D,UAAU,EAAE,SAAS,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC;AAAA,UAC5C;AACA;AAAA,QACF;AAAA,QACA,KAAK,YAAY;AACf,gBAAM,IAAI,EAAE;AACZ,eAAK;AAAA,YACH,MAAM,OACJ,cAAc,CAAC,IACX,EAAE,KAAK,kBAAkB,QAAQ,YAAY,IAC7C,EAAE,YAAY,MAAM,GAAG,EAAE;AAAA,YAE/B,UAAU,EAAE,SAAS,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC;AAAA,UAC5C;AACA;AAAA,QACF;AAAA,QACA,SAAS;AACP,eAAK;AAAA,YACH,MAAM,KAAK,EAAE,SAAS;AAAA,YACtB,UAAU,EAAE,SAAS,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC;AAAA,UAC5C;AACA;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,UAAM,UACJ,CAAC,QAAQ,MACT,CAACA,UAA8B;AAC7B,YAAM,SAAS,GAAG,GAAG,SAAS,QAAQ,GAAG,GAAG,IAC1C,QAAQ,IAAI,GAAG,YAAY;AAE7B,aAAO,GAAG,SAASA,MAAK,QACtBA,MAAK,SAAS,SAAS,IAAI,WAAM;AAAA,EAC9BA,MAAK,SAAS,IAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,IACrD;AAEF,WAAO;AAAA,MACL,GAAGD;AAAA,MACH,SAAS,MAAM,QAAQA,KAAI;AAAA,MAC3B,UAAU,MAAM;AACd,cAAM,WAAW,QAAQA,KAAI;AAC7B,eAAO;AAAA,gBAAmB,SAAS;AAAA,EAAS,GAAG;AAAA,UAC7C;AAAA,UACA;AAAA,QACF;AAAA,EAAM,QAAQ,CAAC,EAAE,QAAQ;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AAEA,QAAM,UAAU,CAAC,UACf,iBAAiB,EACd,WAAiB,EACjB,OAAO;AAAA,IACN,MAAME,MAAK,gBAAgB,IAAI;AAAA,IAC/B,MAAM,CAAC,MACL,UAAU;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,UAAU,EAAE,WAAW,IAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,IACzD,CAAC;AAAA,IACH,SAAS,CAAC,MACR,UAAU;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,UAAU,EAAE,WAAW,IAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,IACzD,CAAC;AAAA,IACH,SAAS,CAAC,MACR,UAAU;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,UAAU,EAAE,WAAW,IAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,IACzD,CAAC;AAAA,IACH,MAAM,CAAC,MACL,UAAU;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,UAAU,EAAE,WAAW,IAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,IACzD,CAAC;AAAA,IACH,UAAU,CAAC,MACT,UAAU;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,UAAU,EAAE,WAAW,IAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,IACzD,CAAC;AAAA,IACH,UAAU,CAAC,MACT,UAAU;AAAA,MACR,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA,MACA,UAAU,EAAE,WAAW,IAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC,EAAE,CAAC,CAAC;AAAA,IACzD,CAAC;AAAA,EACL,CAAC;AAEL,SAAO,QAAQ,CAAC,EAAE,IAAI;AACxB;AAMO,IAAM,WAAW,IACnB,YACA;AACH,SAAO,KAAK,EAAE,GAAG,OAAO;AAC1B;;;AFhYO,IAAM,cAAN,cAA0B,MAAM;AAAA,EAsBrC,YACE,SACA,UAII,CAAC,GACL;AAxCJ;AAyCI,UAAM;AA7BR,SAAO,OAAO;AACd,SAAgB,OAAuB;AACvC,SAAO,QAAkB,CAAC;AA4BxB,SAAK,UAAU;AAAA,EAAK;AACpB,QAAI,QAAQ,MAAM;AAChB,WAAK,OAAO,iBAAiB,QAAQ,QAAQ;AAAA,IAC/C;AAEA,QAAI;AACF,YAAM,QAAQ,UAAU;AACxB,WAAK,mBACF,SAAS,CAAC,GAAG,MAAM,CAAC,EAAE,IAAI,CAAC,MAAM;AAlD1C,YAAAC;AAmDU,eAAO;AAAA,UACL,IACE,EAAE,gBAAgB,KAClB,EAAE,cAAc,OAChBA,MAAA,EAAE,YAAY,MAAd,gBAAAA,IAAiB,SACjB;AAAA,UACF,MAAM,EAAE,cAAc,KAAK;AAAA,UAC3B,MAAM,EAAE,YAAY,IAChB,SAAS,QAAQ,IAAI,GAAG,EAAE,YAAY,CAAW,IACjD;AAAA,QACN;AAAA,MACF,CAAC,KAAK,CAAC;AAAA,IACX,QAAE;AACA,WAAK,kBAAkB,CAAC;AAAA,IAC1B;AAEA,SAAK,KAAK,KAAK,gBAAgB,GAAG,MAAM;AACxC,SAAK,OAAO,KAAK,gBAAgB,GAAG,QAAQ;AAC5C,SAAK,OAAO,KAAK,gBAAgB,GAAG,QAAQ;AAG5C,QAAI,oBAAoB,QAAQ,KAAK,GAAG;AACtC,WAAK,OAAO,UAAU,KAAK,eAAe,KAAK,uBAC7C,QAAQ,QAAQ,QAAQ,MAAM;AAAA,IAElC;AAEA,QAAI,QAAQ,OAAO;AACjB,YAAM,OACJ,QAAQ,iBAAiB,QACrB,QAAQ,MAAM,KAAK,QAAQ,kBAAkB,EAAE,IAC/C;AACN,YAAM,aAAa;AAAA;AAAA,gCAAqC;AAAA,EACtD,QAAQ,iBAAiB,QACrB,QAAQ,MAAM,UACd,OAAO,QAAQ,KAAK;AAE1B,WAAK,UAAU,GAAG,KAAK,UAAU;AACjC,WAAK,QAAQ,CAAC,GAAG,KAAK,OAAO,IAAI;AAAA,IACnC,OAAO;AACL,UAAI,QAAQ,SAAS;AACnB,cAAM,cAAc,kBAAkB,QAAQ,OAAO,IACjD,CAAC,QAAQ,OAAO,IAChB,MAAM,QAAQ,QAAQ,OAAO,IAC7B,QAAQ,UACR,CAAC,QAAQ,OAAO;AAEpB,mBAAW,CAAC,KAAK,CAAC,KAAK,YAAY,QAAQ,GAAG;AAC5C,gBAAM,QAAQ,kBAAkB,CAAC,IAAI,GAAG,EAAE;AAAA,IAAS,GAAG,CAAC,GAAG;AAAA;AAC1D,gBAAM,YAAY,kBAAkB,CAAC,IAAI,EAAE,KAAK;AAEhD,eAAK,UAAU,GAAG,KAAK;AAAA;AAAA,EAAc,QAAQ,KAAK;AAAA,YAChD,QAAQ,SAAS;AAAA,YACjB;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,UAAI,KAAK,MAAM,SAAS,GAAG;AACzB,aAAK,UAAU,GAAG,KAAK;AAAA;AAAA,QAAoB,KAAK,MAAM;AAAA,UACpD,CAAC,GAAG,QAAQ,GAAG,QAAQ;AAAA,QACzB;AAAA,MACF;AAAA,IACF;AAEA,SAAK,UAAU,GAAG,KAAK;AAAA;AACvB,eAAW,KAAK,KAAK,iBAAiB;AACpC,WAAK,YAAU,OAAE,SAAF,mBAAQ,SAAS,YAC5B,KAAK,UACL,GAAG,KAAK;AAAA,MAAgB,EAAE,KAAK,GAAG,EAAE,UAAU,KAAK,EAAE,QAAQ,EAAE;AAAA,IACrE;AACA,SAAK,kBAAkB,CAAC;AAAA,EAC1B;AAAA,EAxGO,SAAS;AACd,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,SAAS,KAAK;AAAA,IAChB;AAAA,EACF;AAAA,EAEO,WAAW;AAChB,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,SAAS,KAAK;AAAA,IAChB;AAAA,EACF;AA6FF;;;AD/GO,SAAS,eAAe,MAAc,MAAyB;AACpE,QAAM,SAAS,IAAI,OAAO;AAC1B,QAAM,WAAW,OAAO;AACxB,WAAS,KAAK,YAAY;AAC1B,MAAI,MAAM;AACR,aAAS,KAAK,YAAY;AAAA,EAC5B;AACA,SAAO;AACT;AAKO,SAAS,eACd,SACoD;AACpD,QAAM,SAAS,IAAI,OAAO;AAC1B,QAAM,WAAW,OAAO;AACxB,QAAM,WAAW,SAAS,uBAAuB;AACjD,MAAI,SAAS;AACX,aAAS,OAAO,MAAM,OAAO,CAAC;AAAA,EAChC;AAEA,SAAO;AACT;AAMO,IAAM,aAAa,CAAC,SAA+C;AACxE,QAAM,OAAO,eAAe,IAAI;AAChC,MAAI,cAAc,IAAI,GAAG;AACvB,WAAO,KAAK;AAAA,EACd,WAAW,eAAe,IAAI,GAAG;AAC/B,WAAO,KAAK;AAAA,EACd,OAAO;AACL,UAAM,IAAI;AAAA,MACR;AAAA,MACA,EAAE,MAAM,gBAAgB,SAAS,KAAK;AAAA,IACxC;AAAA,EACF;AACF;AAKO,SAAS,eAAe,MAAsB;AACnD,MAAI,CAAC,MAAM;AACT,WAAO,IAAI,KAAK,EAAE;AAAA,EACpB;AAEA,QAAM,OAAO,eAAe,IAAI;AAChC,MAAI,eAAe,IAAI,GAAG;AACxB,WAAO,KAAK;AAAA,EACd,OAAO;AACL,UAAM,IAAI;AAAA,MACR,kEAAkE;AAAA,MAClE,EAAE,MAAM,wBAAwB,SAAS,KAAK;AAAA,IAChD;AAAA,EACF;AACF;AAEO,SAAS,kBAAkB,SAA4B;AAC5D,SAAO,IAAI,QAAQ,OAAO;AAC5B;AAKO,IAAM,gBAAgB,CAC3B,IACA,WAEA,iBAAiB,EACd,WAAqB,EACrB,OAAO;AAAA,EACN,MAAM,CAAC,MAAM;AACX,QAAI,UAAU,CAAC,GAAG;AAChB,aAAO,cAAc,CAAC;AAAA,IACxB,OAAO;AACL,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,SAAS,EAAE;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAAA,EACA,MAAM,CAAC,MAAM;AACX,UAAM,OAAO,eAAe,CAAC;AAC7B,QAAI,cAAc,IAAI,GAAG;AACvB,UAAI,QAAQ;AACV,eAAO,OAAO,KAAK,iBAAiB;AACpC,eAAO,iCAAQ;AAAA,MACjB;AAEA,aAAO,KAAK;AAAA,IACd,OAAO;AACL,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,MAAM,uBAAuB,SAAS,KAAK;AAAA,MAC/C;AAAA,IACF;AAAA,EACF;AAAA,EACA,SAAS;AAAA,EACT,MAAM,CAAC,MAAM;AACX,UAAM,IAAI;AAAA,MACR;AAAA,MACA,EAAE,MAAM,uBAAuB,SAAS,EAAE;AAAA,IAC5C;AAAA,EACF;AAAA,EACA,SAAS,CAAC,MAAM;AACd,UAAM,IAAI;AAAA,MACR;AAAA,MACA,EAAE,MAAM,0BAA0B,SAAS,EAAE;AAAA,IAC/C;AAAA,EACF;AAAA,EACA,UAAU,CAAC,MAAM;AACf,QAAI,UAAU,EAAE,iBAAiB,GAAG;AAClC,aAAO,EAAE;AAAA,IACX,OAAO;AACL,YAAM,IAAI;AAAA,QACR;AAAA;AAAA,EAA8C,OAAO,CAAC;AAAA,QACtD,EAAE,MAAM,kBAAkB;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AAAA,EACA,UAAU,CAAC,MAAM;AACf,QAAI,cAAc,CAAC,GAAG;AACpB,UAAI,QAAQ;AACV,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,aAAO,EAAE;AAAA,IACX,OAAO;AACL,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,MAAM,2BAA2B,SAAS,EAAE;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AACF,CAAC,EAAE,EAAE;AAwCT,IAAM,gBAAgB,CAAC,YAA4B;AACjD,SAAO,QACJ;AAAA,IACC,CAAC,CAAC,UAAU,IAAI,MACd;AAAA;AAAA,IAAS;AAAA,EAAe,OAAO,KAAK,IAAI,EACrC,IAAI,CAAC,MAAM,OAAO,UAAU,CAAC,MAAM,KAAK,KAAK,EAC7C,KAAK,IAAI;AAAA;AAAA,EAChB,EACC,KAAK,IAAI;AACd;AAMO,IAAM,oBAAoB,CAC/B,OAAU,eACP;AACH,QAAM,eAA8C,CAAC;AACrD,QAAM,aAA6B,CAAC;AACpC,MAAI,aAAa;AACjB,MAAI,WAAW;AACf,MAAI,UAA0B;AAE9B,QAAM,MAAmB;AAAA,IACvB,eACE,MACA,OACA,QAAQ,SACR;AACA,UAAI,EAAE,SAAS,eAAe;AAC5B,qBAAa,SAAS,CAAC;AAAA,MACzB;AACA,mBAAa,OAAO,KAAK,EAAE,MAAM,KAAK,QAAQ,OAAO,EAAE,GAAG,MAAM,CAAC;AAEjE,aAAO;AAAA,IACT;AAAA,IACA,mBAAmB,UAAU,IAAI;AAC/B,YAAM,WAAqB;AAAA,QACzB,UAAU,CAAC,OAAO,SAAS;AACzB,gBAAM,gBAAgB,GAAG,YAAY;AACrC,qBAAW,KAAK,CAAC,eAAe,IAAI,CAAC;AACrC,iBAAO;AAAA,QACT;AAAA,QACA,UAAU,CAAC,SAAS;AAClB,qBAAW,KAAK,CAAC,UAAU,IAAI,CAAC;AAChC,iBAAO;AAAA,QACT;AAAA,MACF;AACA,SAAG,QAAQ;AACX,aAAO;AAAA,IACT;AAAA,IACA,gBACE,YACA,QAAQ,SACR;AACA,iBAAW,KAAK,OAAO,KAAK,UAAU,GAAG;AACvC,YAAI,eAAe,GAAG,WAAW,IAAI,KAAK;AAAA,MAC5C;AAEA,aAAO;AAAA,IACT;AAAA,IACA,uBAAuB,MAAM,SAAS,MAAM;AAC1C,gBAAU;AACV,mBAAa;AACb,iBAAW;AAEX,aAAO;AAAA,IACT;AAAA,IAEA,SAAS;AACP,YAAM,cAAc,CAAC,OAAe,SAClC,GAAG;AAAA,EAAY,OAAO,KAAK,IAAI,EAC5B;AAAA,QACC,CAAC,SACC,SAAS,KAAK,MAAM,SAAS,KAAK,MAAM,QACtC,OAAO,KAAK,IAAI,EAAE,SAAS,GAAG,IAAI,KAAK;AAAA,MAE7C,EACC,KAAK,IAAI;AAAA;AAEd,UAAI,OAAO;AAEX,iBAAW,KAAK,OAAO,KAAK,YAAY,GAAG;AACzC,eAAO,GAAG,OAAO,YAAY,GAAG,aAAa,EAAE;AAAA;AAAA,MACjD;AAEA,aAAO,GAAG,OAAO,cAAc,UAAU;AAEzC,aAAO,aACH;AAAA,QACE,gBAAgB,WACd,WAAW,YAAY;AAAA,EACnB;AAAA;AAAA,MACR,IACA,cAAc,gBAAgB;AAAA,EAAW;AAAA,SAAgB;AAAA,IAC/D;AAAA,EACF;AAEA,SAAO;AACT;;;AD1QO,IAAM,eACX,CAAmB,SACnB,CAAmB,UACnB,CAA6B,SAAe;AAC1C,QAAM,cAAc,CAAC,MAAa;AAChC,UAAM,IAAI;AAAA,MACR,kEAAkE;AAAA,QAChE;AAAA,MACF;AAAA,MACA,EAAE,MAAM,gBAAgB,SAAS,kBAAkB;AAAA,IACrD;AAAA,EACF;AACA,QAAM,SAAS,iBAAiB,EAC7B,OAAO,EACP,OAAO;AAAA,IACN,MAAM,CAAC,MACLC,MAAK,GAAG,gBAAgB,CAAC,MAAM,aAAa,IAAI,EAAE,KAAK,EAAE,CAAC,GAAG,MAAM;AAAA,IACrE,MAAM,CAAC,MAAM,YAAY,CAAC;AAAA,IAC1B,SAAS,CAAC,MAAM,YAAY,CAAC;AAAA,IAC7B,MAAM,CAAC,MAAM,YAAY,CAAC;AAAA,IAC1B,UAAU,CAAC,MAAM;AACf,QAAE,kBAAkB,aAAa,MAAM,KAAK;AAC5C,aAAO;AAAA,IACT;AAAA,IACA,UAAU,CAAC,MAAM;AACf,QAAE,KAAK,kBAAkB,aAAa,MAAM,KAAK;AACjD,aAAO;AAAA,IACT;AAAA,IACA,SAAS,CAAC,MAAM;AACd,QAAE,aAAa,MAAM,KAAK;AAC1B,aAAO;AAAA,IACT;AAAA,EACF,CAAC,EAAE,IAAI;AAET,SAAO;AACT;AAEK,IAAM,eAAe,CAAmB,SAA6B;AAC1E,SAAO,iBAAiB,QAAQ,QAAQ,SAAS,EAC9C,WAAmB,EACnB,OAAO;AAAA,IACN,MAAM,CAAC,MAAMA,MAAK,GAAG,gBAAgB,aAAa,IAAI,CAAC;AAAA,IACvD,UAAU,CAAC,MAAM,EAAE,kBAAkB,aAAa,IAAI;AAAA,IACtD,UAAU,CAAC,QAAQ,IAAI,KAAK,kBAAkB,aAAa,IAAI;AAAA,IAC/D,SAAS,CAAC,OAAO,GAAG,aAAa,IAAI;AAAA,EACvC,CAAC;AACL;AAEA,IAAM,WAAW,aAAa,OAAO;AACrC,IAAM,WAAW,aAAa,OAAO;AAK9B,IAAM,eAAe,CAAC,cAAiD;AAC5E,MAAI,CAAC,WAAW;AACd,WAAO,CAAC;AAAA,EACV;AAEA,SAAO,iBAAiB,EACrB,WAAqB,EACrB,OAAO;AAAA,IACN,MAAM,CAAC,MAAMA,MAAK,GAAG,gBAAgB,YAAY;AAAA,IACjD,UAAU,CAAC,MAAG;AA5FpB;AA4FuB,6BAAS,EAAE,KAAK,iBAAiB,MAAjC,mBAAoC,MAAM,WAAU,CAAC;AAAA;AAAA,IACtE,UAAU,CAAC,MAAG;AA7FpB;AA6FuB,6BAAS,EAAE,iBAAiB,MAA5B,mBAA+B,MAAM,WAAU,CAAC;AAAA;AAAA,IACjE,SAAS,CAAC,MAAG;AA9FnB;AA8FsB,6BAAS,CAAC,MAAV,mBAAa,MAAM,WAAU,CAAC;AAAA;AAAA,IAC9C,MAAM,CAAC,MAAM;AACX,YAAM,IAAI,YAAY,0CAA0C;AAAA,QAC9D,MAAM;AAAA,QACN,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAAA,IACA,SAAS,CAAC,MAAM;AACd,YAAM,IAAI,YAAY,6CAA6C;AAAA,QACjE,MAAM;AAAA,QACN,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAAA,IACA,MAAM,CAAC,MAAM;AACX,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,MAAM,gBAAgB,SAAS,EAAE;AAAA,MACrC;AAAA,IACF;AAAA,EACF,CAAC,EAAE,SAAS,EACX,OAAO,OAAO;AACnB;AAcO,IAAM,cACX,CAA8B,WAC9B,CAAsC,QAAc;AAnItD;AAoII,QAAM,YAAU,cAAS,GAAG,MAAZ,mBAAe,MAAM,YAAW,CAAC;AACjD,QAAM,WAAqB,MAAM,QAAQ,MAAM,IAAI,SAAS,CAAC,MAAM;AAEnE,QAAM,uBAAuB;AAAA,IAC3B,GAAG,IAAI,IAAY,QAAQ,OAAO,CAAC,MAAM,CAAC,SAAS,SAAS,CAAC,CAAC,CAAC;AAAA,EACjE,EACG,OAAO,OAAO,EACd,KAAK,GAAG;AAEX,SAAO,SAAS,oBAAoB,EAAE,GAAG;AAC3C;AAYK,IAAM,WACX,IAAqC,QACrC,CAAsC,QAAc;AA5JtD;AA6JI,QAAM,QAAS,MAAM,QAAQ,GAAG,IAAI,IAAI,KAAK,IAAI,CAAC,GAAG;AAErD,QAAM,mBAAiB,cAAS,GAAG,MAAZ,mBAAe,MAAM,YAAW,CAAC;AACxD,QAAM,mBAAmB;AAAA,IACvB,GAAG,oBAAI,IAAY,CAAC,GAAG,gBAAgB,GAAG,KAAK,CAAC;AAAA,EAClD;AAEA,SAAO,SAAS,iBAAiB,KAAK,GAAG,EAAE,KAAK,CAAC,EAAE,GAAG;AACxD;AAEK,IAAM,cAAc,CAAC,OAAqB,UAAkB;AACjE,SAAO,CAA4B,OAAa;AAC9C,UAAM,SAAS,OAAO,OAAO;AAC7B,UAAM,QAAQ,aAAa,QAAQ,EAAE,SAAS,cAAc,EAAE,IAAI,EAAE;AACpE,UAAM,OAAO,QACT,MAAM,QAAQ,KAAK,KAAK,WAAW,UAAU,IAC7C,KAAK,WAAW;AACpB,UAAM,KAAK,aAAa,QAAQ,EAAE,IAAI,EAAE,EAAE;AAE1C,WAAQ,SAAS,OAAO,EAAE,IAAI;AAAA,EAChC;AACF;AAMA,SAAS,kBACP,SACgC;AAChC,SAAO,OAAO,QAAQ,OAAO;AAC/B;AAaO,IAAM,gBACX,IAAwD,SACxD,CAAsC,QAAc;AAClD,QAAM,KACJ,WAAW,GAAG,KAAK,WAAW,GAAG,IAC5B,IAAI,oBACL,UAAU,GAAG,IACZ,MACD;AACN,MAAI,CAAC,IAAI;AACP,UAAM,IAAI;AAAA,MACR;AAAA,MACA,EAAE,MAAM,iBAAiB,SAAS,IAAI;AAAA,IACxC;AAAA,EACF;AAEA,QAAM,UAAU,kBAAkB,IAAI,IACjC,KAAK,MAAM,CAAC,IACZ;AACL,QAAM,KAAK,kBAAkB,IAAI,IAAI,KAAK,KAAK;AAC/C,QAAM,UAAU,aAAa,EAAE;AAC/B,QAAM,UAAoB,CAAC;AAE3B,aAAW,SAAS,SAAS;AAC3B,UAAM,UAAU,CAAC,QAAQ;AAAA,MAAM,CAAC,MAC9B,OAAO,MAAM,WAAW,EAAE,KAAK,MAAM,MAAM,KAAK,IAAI,CAAC,EAAE,KAAK,KAAK;AAAA,IACnE;AACA,QAAI,SAAS;AACX,cAAQ,KAAK,KAAK;AAAA,IACpB;AAAA,EACF;AAEA,WAAS,QAAQ,OAAO,CAAC,MAAM,CAAC,QAAQ,SAAS,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,EAAE,GAAG;AAEnE,MAAI,IAAI;AACN,OAAG,OAAO;AAAA,EACZ;AAEA,SAAO;AACT;AAKK,IAAM,mBAAmB,CAAC,SAA0B;AACzD,QAAM,IAAI,OAAO,SAAS,WAAW,WAAW,IAAI,IAAI;AACxD,SAAO,iBAAiB,EACrB,WAAoB,EACpB,OAAO;AAAA,IACN,MAAM,MAAM;AAAA,IACZ,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE;AAAA,IACjB,SAAS,CAAC,MAAM,CAAC,CAAC,EAAE;AAAA,IACpB,SAAS,CAAC,MAAM,CAAC,CAAC,EAAE;AAAA,IACpB,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE;AAAA,IACrB,UAAU,MAAM;AAAA,IAChB,MAAM,CAACC,OAAM,CAAC,CAACA,GAAE;AAAA,EACnB,CAAC,EAAE,CAAC;AACR;AAMO,IAAM,YAAY,CAAC,SAA0B;AAClD,SAAO,iBAAiB,IAAI,IAAK,KAAmB,gBAAgB;AACtE;;;AQhPO,IAAM,SAAS,CACpB,SACG;AACH,QAAM,eAAe,OAAO,SAAS;AACrC,MAAI,WAA2C,eAC3C,eAAe,IAAI,IACnB,UAAU,IAAI,IACb,OACD,WAAW,IAAI,KAAK,WAAW,IAAI,IACnC,OACC;AAEL,MAAI,CAAC,UAAU;AACb,UAAM,IAAI;AAAA,MACR,6CAA6C,YAAY,IAAI;AAAA,MAC7D,EAAE,MAAM,iBAAiB,SAAS,KAAK;AAAA,IACzC;AAAA,EACF;AAGA,QAAM,MAAuB;AAAA,IAC3B,MAAM,MAAM;AACV,aAAO,eAAe,SAAS,YAAY,QAAQ;AAAA,IACrD;AAAA,IAEA,SAAS,CAA+B,QAAW;AACjD,aAAO,MACF,SAAS,iBAAiB,GAAG,IAC9B,iBAAiB,QAAQ;AAAA,IAC/B;AAAA,IAEA,WAAW,CACT,KACA,aACqD;AACrD,YAAM,SAAS,SAAS,cAAc,GAAG;AACzC,UAAI,CAAC,UAAU,UAAU;AACvB,cAAM,IAAI;AAAA,UACR,GAAG;AAAA;AAAA;AAAA,EAAyD;AAAA,YAC1D;AAAA,UACF;AAAA,UACA,EAAE,MAAM,sBAAsB,SAAS,SAAS;AAAA,QAClD;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,IAEA,QAAQ,CACN,YAGG;AACH,UAAI,CAAC,SAAS;AACZ,eAAO;AAAA,MACT;AAEA,YAAM,QAAQ,MAAM,QAAQ,OAAO,IAC9B,QAAQ,OAAO,OAAO,IACvB,CAAC,OAAO;AACZ,eAAS,OAAO,GAAG,KAAK;AAExB,aAAO;AAAA,IACT;AAAA,IAeA,QACE,CAAC,WAAoB,kBAAoC,UACzD,CAA4B,WAAgC;AAC1D,YAAM,KAAK,YACN,qCAAU,cAAc,aACzB,UAAU,QAAQ,IAClB,WACA,SAAS,oBACT,SAAS,oBACT;AAEJ,UAAI,IAAI;AACN,YAAI;AACJ,YAAI;AACF,0BAAiB;AAAA,YACf;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF,SAAS,OAAP;AACA,gBAAM,IAAI;AAAA,YACR,iEAAiE;AAAA;AAAA,UAAgC;AAAA,cAC/F;AAAA,YACF;AAAA;AAAA,EACE,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,YAEvD;AAAA,cACE,MAAM,UAAU,OAAO,uBAAuB;AAAA,cAC9C,SAAS;AAAA,YACX;AAAA,UACF;AAAA,QACF;AAEA,YAAI,kBAAkB,OAAO;AAC3B,aAAG,OAAO;AAAA,QACZ,WAAW,CAAC,UAAU,aAAa,GAAG;AACpC,gBAAM,IAAI;AAAA,YACR,yCAAyC;AAAA,cACvC;AAAA,YACF,aAAa;AAAA,YACb,EAAE,MAAM,iBAAiB,SAAS,GAAG;AAAA,UACvC;AAAA,QACF;AAAA,MACF,OAAO;AACL,YAAI,iBAAiB;AACnB,gBAAM,IAAI;AAAA,YACR,oBAAoB,OAChB,kBAAkB,6EAClB;AAAA,YACJ;AAAA,cACE,MAAM,UAAU;AAAA,cAChB,SAAS,CAAC,eAAe,QAAQ;AAAA,YACnC;AAAA,UACF;AAAA,QACF;AAEA,YAAI,CAAC,WAAW;AACd,gBAAM,IAAI;AAAA,YACR,8KAAgL,OAAO,WACrL,OAAO,aAAa,WAChB;AAAA,cACN,YAAY,QAAQ,oBAAoB;AAAA,cAChC;AAAA,YACF,eAAe,UAAU,QAAQ,gBAC/B,SAAS,WAAW,YAEtB;AAAA,UAER;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,IAUF,WACE,CAA+B,cAC/B,CAA4B,WAAgC;AAI1D,YAAM,WACJ,YACI,SAAS,iBAAiB,SAAS,IACnC,iBAAiB,QAAQ;AAG/B,iBAAW,CAAC,KAAK,EAAE,KAAK,SAAS,QAAQ,GAAG;AAC1C,YAAI,UAAU,EAAE,GAAG;AACjB,cAAI;AACJ,cAAI;AACF,4BAAiB;AAAA,cACf;AAAA,cACA;AAAA,cACA,SAAS;AAAA,YACX;AAAA,UACF,SAAS,OAAP;AACA,kBAAM,IAAI;AAAA,cACR,uEAAuE;AAAA;AAAA,UAAgC;AAAA,gBACrG;AAAA,cACF,MAAM,YAAY,SAAS;AAAA;AAAA,EACzB,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,cAEvD;AAAA,gBACE,MAAM,UAAU,OAAO,uBAAuB;AAAA,gBAC9C,SAAS;AAAA,cACX;AAAA,YACF;AAAA,UACF;AAEA,cAAI,kBAAkB,OAAO;AAC3B,eAAG,OAAO;AAAA,UACZ,WAAW,CAAC,UAAU,aAAa,GAAG;AAEpC,kBAAM,IAAI;AAAA,cACR,2DAA2D,eAAe;AAAA,gBACxE;AAAA,cACF,MAAM,YACJ,SAAS,qGACoF,OAAO;AAAA,cACtG,EAAE,MAAM,6CAA6C;AAAA,YACvD;AAAA,UACF;AAAA,QACF,OAAO;AACL,gBAAM,IAAI;AAAA,YACR,4DAA4D,KAAK;AAAA,cAC/D,QAAQ,EAAE;AAAA,cACV;AAAA,cACA;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,IAWF,QAAQ,CAAC,cAAc,CAAC,WAAW;AACjC,YAAM,aAAa,CAAC;AACpB,YAAM,WAAuB,YACzB,SAAS,iBAAiB,SAAS,IACnC,iBAAiB,QAAQ;AAE7B,iBAAW,MAAM,UAAU;AACzB,mBAAW,KAAK,OAAO,MAAM,EAAE,CAAC,CAAC;AAAA,MACnC;AAEA,aAAO;AAAA,IACT;AAAA,IAOA,WAAW,CACT,WACA,OACG;AACH,iBAAW,MAAM,qCAAU,iBAAiB,YAAY;AACtD,YAAI,IAAI;AACN,aAAG,EAAE;AAAA,QACP;AACA,WAAG,OAAO;AAAA,MACZ;AAEA,aAAO;AAAA,IACT;AAAA,IAEA,MAAM,CAAC,SAAS,WAAW;AACzB,UAAI;AACF,cAAM,WACJ,OAAO,YAAY,WAAW,cAAc,OAAO,IAAI;AACzD,mBAAW,KAAK,QAAQ,EAAE,QAAQ;AAElC,eAAO;AAAA,MACT,SAAS,OAAP;AACA,YAAI,oBAAoB,KAAK,KAAK,iBAAiB,OAAO;AACxD,gBAAM,UAAU,SACZ,gCAAgC;AAAA,EAAW,MAAM,YACjD;AAAA,EAAkC,MAAgB;AACtD,gBAAM;AAAA,QACR;AAEA,cAAM;AAAA,MACR;AAAA,IACF;AAAA,IAEA,aAAa,MAAM;AACjB,aAAQ,eAAe,OAAO,QAAQ,IAAI;AAAA,IAK5C;AAAA,EACF;AAEA,SAAO;AACT;","names":["pipe","stack","flow","pipe","pipe","clone","placeholder","pipe","tagName","before","after","prepend","pipe","tree","node","flow","_a","pipe","n"]}