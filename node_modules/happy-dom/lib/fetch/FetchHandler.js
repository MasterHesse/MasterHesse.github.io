"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const RelativeURL_1 = __importDefault(require("../location/RelativeURL"));
const Response_1 = __importDefault(require("./Response"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const Request_1 = __importDefault(require("./Request"));
const url_1 = require("url");
/**
 * Helper class for performing fetch.
 */
class FetchHandler {
    /**
     * Returns resource data asynchronously.
     *
     * @param document Document.
     * @param url URL to resource.
     * @param [init] Init.
     * @returns Response.
     */
    static fetch(document, url, init) {
        const taskManager = document.defaultView.happyDOM.asyncTaskManager;
        const requestInit = { ...init, headers: { ...init?.headers } };
        const cookie = document.defaultView.document.cookie;
        const referer = document.defaultView.location.origin;
        requestInit.headers['user-agent'] = document.defaultView.navigator.userAgent;
        // We need set referer to solve anti-hotlinking.
        // And the browser will set the referer to the origin of the page.
        // Referer is "null" when the URL is set to "about:blank".
        // This is also how the browser behaves.
        if (referer !== 'null') {
            requestInit.headers['referer'] = referer;
        }
        if (cookie) {
            requestInit.headers['set-cookie'] = cookie;
        }
        let request;
        if (typeof url === 'string') {
            request = new Request_1.default(RelativeURL_1.default.getAbsoluteURL(document.defaultView.location, url));
        }
        else if (url instanceof url_1.URL) {
            // URLs are always absolute, no need for getAbsoluteURL.
            request = new Request_1.default(url);
        }
        else {
            request = new Request_1.default(RelativeURL_1.default.getAbsoluteURL(document.defaultView.location, url.url), {
                ...url
            });
        }
        return new Promise((resolve, reject) => {
            const taskID = taskManager.startTask();
            (0, node_fetch_1.default)(request, requestInit)
                .then((response) => {
                if (taskManager.getTaskCount() === 0) {
                    reject(new Error('Failed to complete fetch request. Task was canceled.'));
                }
                else {
                    response.constructor['_ownerDocument'] = document;
                    for (const key of Object.keys(Response_1.default.prototype)) {
                        if (Response_1.default.prototype.hasOwnProperty(key) && key !== 'constructor') {
                            if (typeof Response_1.default.prototype[key] === 'function') {
                                response[key] = Response_1.default.prototype[key].bind(response);
                            }
                            else {
                                response[key] = Response_1.default.prototype[key];
                            }
                        }
                    }
                    taskManager.endTask(taskID);
                    resolve(response);
                }
            })
                .catch((error) => {
                reject(error);
                taskManager.cancelAll(error);
            });
        });
    }
}
exports.default = FetchHandler;
//# sourceMappingURL=FetchHandler.js.map