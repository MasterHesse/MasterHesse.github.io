// src/types/dictionary/MapTo.ts
var MapCardinality = /* @__PURE__ */ ((MapCardinality2) => {
  MapCardinality2["OneToMany"] = "I -> O[]";
  MapCardinality2["OneToOne"] = "I -> O";
  MapCardinality2["ManyToOne"] = "I[] -> O";
  return MapCardinality2;
})(MapCardinality || {});

// src/runtime/keys.ts
function keys(obj, ...without) {
  const v = without.length > 0 ? Object.keys(obj).filter((k) => !without.includes(k)) : Object.keys(obj);
  return v;
}

// src/runtime/createFnWithProps.ts
function createFnWithProps(fn, props) {
  return (() => {
    let combined = fn;
    for (const prop of keys(props)) {
      combined[prop] = props[prop];
    }
    return combined;
  })();
}
function fnWithProps(fn, props) {
  let combined = fn;
  for (const prop of keys(props)) {
    combined[prop] = props[prop];
  }
  return combined;
}
function readonlyFnWithProps(fn, props) {
  let combined = fn;
  for (const prop of keys(props)) {
    combined[prop] = props[prop];
  }
  return combined;
}

// src/runtime/ruleset.ts
function ruleSet(defn) {
  return defn;
}

// src/runtime/api/api.ts
var api = (priv) => (pub) => {
  const surface = () => pub;
  surface.prototype.priv = () => priv;
  return surface;
};

// src/runtime/combinators/and.ts
var and = (...ops) => {
  const fn = (...args) => {
    return [...ops].every((i) => i(...args));
  };
  return fn;
};

// src/runtime/combinators/or.ts
function or(...conditions) {
  return conditions.some((v) => v === true) ? true : false;
}

// src/runtime/combinators/not.ts
var not = (op) => {
  const fn = (...args) => {
    return !op(...args);
  };
  return fn;
};

// src/runtime/runtime/condition.ts
var condition = (c, input) => {
  return c(input);
};

// src/runtime/type-checks/ifSameType.ts
function ifSameType(value, comparisonType, ifExtends, doesNotExtend) {
  return typeof value === typeof comparisonType ? ifExtends(value) : doesNotExtend(value);
}

// src/runtime/type-checks/isArray.ts
function isArray(i) {
  return Array.isArray(i) === true;
}
function ifArray(val, isAnArray, isNotAnArray) {
  return isArray(val) ? isAnArray(val) : isNotAnArray(val);
}
function ifArrayPartial() {
  return (isAnArray, isNotAnArray) => {
    return (val) => ifArray(val, isAnArray, isNotAnArray);
  };
}

// src/runtime/type-checks/isBoolean.ts
function isBoolean(i) {
  return typeof i === "boolean";
}
function ifBoolean(val, ifVal, elseVal) {
  return isBoolean(val) ? ifVal : elseVal;
}

// src/runtime/type-checks/isFalse.ts
function isFalse(i) {
  return typeof i === "boolean" && !i;
}
function ifFalse(val, ifVal, elseVal) {
  return isFalse(val) ? ifVal : elseVal;
}

// src/runtime/type-checks/isFunction.ts
function isFunction(input) {
  return typeof input === "function" ? true : false;
}

// src/runtime/type-checks/isNull.ts
function isNull(i) {
  return i === null;
}
function ifNull(val, ifVal, elseVal) {
  return isNull(val) ? ifVal : elseVal;
}

// src/runtime/type-checks/isNumber.ts
function isNumber(i) {
  return typeof i === "number";
}
function ifNumber(val, ifVal, elseVal) {
  return isNumber(val) ? ifVal : elseVal;
}

// src/runtime/type-checks/isObject.ts
function isObject(i) {
  return typeof i === "object" && i !== null && Array.isArray(i) === false;
}
function ifObject(val, ifObj, notObj) {
  return isObject(val) ? ifObj : notObj;
}

// src/runtime/type-checks/isString.ts
function isString(i) {
  return typeof i === "string";
}
function ifString(val, ifVal, elseVal) {
  return isString(val) ? ifVal : elseVal;
}

// src/runtime/type-checks/isSymbol.ts
function isSymbol(i) {
  return typeof i === "symbol";
}

// src/runtime/type-checks/isTrue.ts
function isTrue(i) {
  return typeof i === "boolean" && i === true;
}
function ifTrue(val, ifVal, elseVal) {
  return isTrue(val) ? ifVal : elseVal;
}

// src/runtime/type-checks/isUndefined.ts
function isUndefined(i) {
  return typeof i === "undefined";
}
function ifUndefined(val, ifVal, elseVal) {
  return isUndefined(val) ? ifVal : elseVal;
}
function ifDefined(val, ifVal, elseVal) {
  return isUndefined(val) ? ifVal : elseVal;
}

// src/runtime/runtime/type.ts
var typeApi = () => ({
  string: {
    name: "string",
    type: "",
    typeGuard: (v) => isString(v),
    is: isString
  },
  boolean: {
    name: "boolean",
    type: true,
    typeGuard: (v) => isBoolean(v),
    is: isBoolean
  },
  number: {
    name: "number",
    type: 1,
    typeGuard: (v) => isNumber(v),
    is: isNumber
  },
  function: {
    name: "function",
    type: Function,
    typeGuard: (v) => isFunction(v),
    is: isFunction
  },
  null: {
    name: "null",
    type: null,
    typeGuard: (v) => isNull(v),
    is: isNull
  },
  symbol: {
    name: "symbol",
    type: Symbol(),
    typeGuard: (v) => isSymbol(v),
    is: isSymbol
  },
  undefined: {
    name: "undefined",
    type: void 0,
    typeGuard: (v) => isUndefined(v),
    is: isUndefined
  },
  true: {
    name: "true",
    type: true,
    typeGuard: (v) => isTrue(v),
    is: isTrue
  },
  false: {
    name: "false",
    type: false,
    typeGuard: (v) => isFalse(v),
    is: isFalse
  },
  object: {
    name: "object",
    type: {},
    typeGuard: (v) => isObject(v),
    is: isObject
  },
  array: {
    name: "array",
    type: {},
    typeGuard: (v) => isArray(v),
    is: isObject
  }
});
function isType(t) {
  return typeof t === "object" && ["name", "type", "is"].every((i) => Object.keys(t).includes(i));
}
function type(fn) {
  const result = fn(typeApi());
  if (!isType(result)) {
    throw new Error(
      `When using type(), the callback passed in returned an invalid type! Value returned was: ${result}`
    );
  }
  return result;
}

// src/runtime/dictionary/entries.ts
function entries(obj) {
  const iterable = {
    *[Symbol.iterator]() {
      for (const k of keys(obj)) {
        yield [k, obj[k]];
      }
    }
  };
  return iterable;
}

// src/runtime/runtime/withValue.ts
function withValue(td) {
  return (obj) => {
    const t = type(td);
    return Object.fromEntries(
      [...entries(obj)].filter(([_key, value]) => {
        return t.typeGuard(value);
      })
    );
  };
}

// src/runtime/lists/asArray.ts
var asArray = (thing, _widen) => {
  return isArray(thing) ? thing : typeof thing === "undefined" ? [] : [thing];
};

// src/runtime/combinators/filter.ts
function isNotFilter(f) {
  return typeof f === "object" && "not" in f;
}
function isNumericFilter(filter2) {
  return "equals" in filter2 || "notEqual" in filter2 || "greaterThan" in filter2 || "lessThan" in filter2 ? true : false;
}
var numericOps = (config, boolLogic) => {
  const equals = (n) => {
    const f = asArray(n);
    return f.length === 0 ? [] : [(input) => f.some((i) => i === input)];
  };
  const notEqual = (n) => {
    const f = asArray(n);
    return f.length === 0 ? [] : [(input) => f.every((i) => i !== input)];
  };
  const greaterThan = (n) => {
    const val = [(input) => input !== void 0 && input > n];
    return val;
  };
  const lessThan = (n) => {
    const val = [(input) => input !== void 0 && input < n];
    return val;
  };
  const conditions = [
    ..."equals" in config ? equals(config.equals) : [],
    ..."notEqual" in config ? notEqual(config.notEqual) : [],
    ..."greaterThan" in config ? greaterThan(config.greaterThan) : [],
    ..."lessThan" in config ? lessThan(config.lessThan) : []
  ];
  const combined = boolLogic === "AND" ? (input) => conditions.every((c) => c(input)) : (input) => conditions.some((c) => c(input));
  return combined;
};
var stringOps = (config, boolLogic) => {
  const startsWith = (n) => {
    const f = asArray(n);
    return f.length === 0 ? [] : [(input) => f.some((i) => input?.startsWith(i))];
  };
  const endsWith = (n) => {
    const f = asArray(n);
    return f.length === 0 ? [] : [(input) => f.some((i) => input?.endsWith(i))];
  };
  const contains = (n) => {
    const f = asArray(n);
    return f.length === 0 ? [] : [(input) => f.some((i) => input?.includes(i))];
  };
  const conditions = [
    ..."startsWith" in config ? startsWith(config.startsWith) : [],
    ..."endsWith" in config ? endsWith(config.endsWith) : [],
    ..."contains" in config ? contains(config.contains) : []
  ];
  const combined = boolLogic === "AND" ? (input) => conditions.every((c) => c(input)) : (input) => conditions.some((c) => c(input));
  return combined;
};
var filterFn = (defn, logicCombinator, ifUndefined2 = "no-impact") => {
  const config = isNotFilter(defn) ? defn["not"] : defn;
  const filter2 = (input) => {
    const undefValue = ifUndefined2 === "no-impact" ? logicCombinator === "AND" ? true : false : ifUndefined2;
    let flag;
    if (typeof input === "undefined") {
      flag = undefValue;
    } else if (isNumericFilter(config)) {
      const fn = numericOps(config, logicCombinator);
      flag = isNotFilter(defn) ? !fn(input) : fn(input);
    } else {
      const fn = stringOps(config, logicCombinator);
      flag = isNotFilter(defn) ? !fn(input) : fn(input);
    }
    return flag;
  };
  return filter2;
};
var filter = (config, logicCombinator = "AND", ifUndefined2 = "no-impact") => {
  return filterFn(config, logicCombinator, ifUndefined2);
};

// src/runtime/dictionary/arrayToKeyLookup.ts
function arrayToKeyLookup(...keys2) {
  const obj = {};
  for (const key of keys2) {
    obj[key] = true;
  }
  return obj;
}

// src/runtime/dictionary/defineProperties.ts
function defineProperties(obj) {
  return {
    ro(prop, errorMsg) {
      Object.defineProperty(obj, prop, {
        writable: false,
        set(v) {
          const message = errorMsg ? errorMsg(prop, v) : `The ${String(
            prop
          )} is readonly but an attempt was made to change it's value to "${JSON.stringify(
            v
          )}"!`;
          throw new Error(message);
        }
      });
      return obj;
    }
  };
}

// src/runtime/dictionary/dictionaryTransform.ts
function dictionaryTransform(input, transform) {
  return keys(input).reduce((acc, i) => {
    const key = i;
    return { ...acc, [key]: transform(input, key) };
  }, {});
}

// src/runtime/dictionary/dictArr.ts
var dictArr = (...dicts) => {
  const api2 = {
    length: dicts.length,
    toLookup: (prop) => {
      let dict = {};
      for (const obj of dicts) {
        const key = obj[prop];
        dict = { ...dict, [key]: obj };
      }
      return dict;
    },
    unique: (prop) => {
      const v = /* @__PURE__ */ new Set();
      dicts.forEach((i) => v.add(i[prop]));
      const size = dictArr(...dicts).count(prop);
      const values = Array.from(v);
      const u = {
        isUnique: values.includes(void 0) ? size === v.size - 1 : size === v.size,
        includedUndefined: values.includes(void 0) ? true : false,
        size,
        values
      };
      return u;
    },
    sum: (prop) => {
      return dicts.reduce((acc, obj) => prop in obj ? acc + obj[prop] : acc, 0);
    },
    count: (prop) => {
      return dicts.reduce(
        (acc, obj) => prop in obj && typeof obj[prop] !== "undefined" ? acc + 1 : acc,
        0
      );
    }
  };
  return api2;
};

// src/runtime/dictionary/mapValues.ts
function mapValues(obj, valueMapper) {
  return Object.fromEntries(
    [...entries(obj)].map(([k, v]) => [k, valueMapper(v)])
  );
}

// src/runtime/dictionary/mapTo.ts
var toFinalizedConfig = (config) => {
  return { ...config, finalized: true };
};
var DEFAULT_ONE_TO_MANY_MAPPING = toFinalizedConfig({
  input: "req",
  output: "opt",
  cardinality: "I -> O[]"
});
var DEFAULT_ONE_TO_ONE_MAPPING = toFinalizedConfig({
  input: "req",
  output: "req",
  cardinality: "I -> O"
});
var DEFAULT_MANY_TO_ONE_MAPPING = toFinalizedConfig({
  input: "req",
  output: "req",
  cardinality: "I[] -> O"
});
var debugMsg = (config, source, output) => {
  if (config.debug) {
    console.error(
      `MapFn[${typeof config.output === "string" ? `${config.output}, ` : ""}${config.input}, ${config.cardinality}, ${config.output}] received:

${JSON.stringify(source)}

And produced: ${JSON.stringify(
        output
      )}

`
    );
  }
};
var mapper = (config) => (map) => {
  const fn = (source) => {
    const isArray2 = config.cardinality === "I -> O[]" && Array.isArray(source) ? true : config.cardinality === "I[] -> O" && Array.isArray(source) && Array.isArray(source[0]) ? true : false;
    if (isArray2) {
      const output = source.flatMap(map);
      debugMsg(config, source, output);
      return output;
    } else {
      const output = map(source);
      debugMsg(config, source, output);
      return output;
    }
  };
  return createFnWithProps(fn, {
    input: config.input,
    output: config.output,
    cardinality: config.cardinality,
    debug: config.debug,
    inputType: {},
    outputType: {},
    fnSignature: null
  });
};
var setMapper = (config = { input: void 0, output: void 0, cardinality: void 0 }, defaultValue) => ({
  map: (source) => {
    const c = {
      ...defaultValue,
      ...config
    };
    return mapper(c)(source);
  },
  input: config?.input || defaultValue.input,
  output: config?.output || defaultValue.output,
  cardinality: config?.cardinality || defaultValue.cardinality,
  debug: config?.debug || false
});
var mapToFn = (map) => {
  return mapper(DEFAULT_ONE_TO_MANY_MAPPING)(map);
};
var mapToDict = {
  config(config) {
    const c = { ...DEFAULT_ONE_TO_MANY_MAPPING, ...config };
    return setMapper(c, DEFAULT_ONE_TO_MANY_MAPPING);
  },
  oneToOne(config) {
    const c = { ...DEFAULT_ONE_TO_ONE_MAPPING, ...config };
    return setMapper(c, DEFAULT_ONE_TO_ONE_MAPPING);
  },
  manyToOne(config) {
    const c = { ...DEFAULT_MANY_TO_ONE_MAPPING, ...config };
    return setMapper(c, DEFAULT_MANY_TO_ONE_MAPPING);
  },
  oneToMany(config) {
    const c = { ...DEFAULT_ONE_TO_MANY_MAPPING, ...config };
    return setMapper(c, DEFAULT_ONE_TO_MANY_MAPPING);
  }
};
var mapTo = createFnWithProps(mapToFn, mapToDict);

// src/runtime/dictionary/strArrayToDict.ts
function strArrayToDict(...strings) {
  return strings.reduce((acc, str) => {
    acc = { ...acc, [str]: true };
    return acc;
  }, {});
}

// src/runtime/dictionary/kv/dictToKv.ts
function dictToKv(obj, _makeTuple = false) {
  return keys(obj).map((k) => {
    return { key: k, value: obj[k] };
  });
}

// src/runtime/state/Configurator.ts
function omit(obj, ...removals) {
  const untyped = removals;
  return Object.fromEntries(Object.entries(obj).filter(([key]) => !untyped.includes(key)));
}
function Configurator() {
  let configuration = () => ({});
  const api2 = () => {
    return {
      set(key, value) {
        const keyValue = { [key]: value };
        const config = configuration();
        const updated = { ...config, ...keyValue };
        configuration = () => updated;
        return updated;
      },
      remove(key) {
        const config = configuration();
        const updated = omit(config, key);
        configuration = () => updated;
        return updated;
      },
      done() {
        return configuration();
      }
    };
  };
  return api2();
}

// src/runtime/state/FluentConfigurator.ts
function FluentConfigurator(initial = {}) {
  const api2 = (current) => {
    return {
      set(key, value) {
        const keyValue = { [key]: value };
        const updated = { ...keyValue, ...current };
        return api2(updated);
      },
      done() {
        return current;
      }
    };
  };
  if (initial && typeof initial !== "object") {
    throw new Error(
      "The FluentConfigurator was passed a non-object based value as the initial value. This is not allowed."
    );
  }
  return initial ? api2(initial) : api2({});
}

// src/runtime/dictionary/kv/filterDictArray.ts
function filterDictArray(dictArr2, cb) {
  const state = Configurator();
  const updated = dictArr2.filter((i) => {
    const [k, v] = i;
    const keep = cb(k, v);
    if (!keep) {
      state.set(k, true);
    }
    return keep;
  });
  return updated;
}

// src/runtime/dictionary/kv/kv.ts
function kv(key, value) {
  return { [key]: value };
}

// src/runtime/dictionary/kv/kvToDict.ts
function kvToDict(kvArr) {
  const out = {};
  for (const kv2 of kvArr) {
    out[kv2.key] = kv2.value;
  }
  return out;
}

// src/runtime/lists/groupBy.ts
function groupBy(_data) {
  throw new Error("not implemented");
}

// src/runtime/literals/box.ts
function box(value) {
  const rtn = {
    __kind: "box",
    value,
    unbox: (...p) => {
      return typeof value === "function" ? value(...p) : value;
    }
  };
  return rtn;
}
function isBox(thing) {
  return typeof thing === "object" && "__kind" in thing && thing.__kind === "box";
}
function boxDictionaryValues(dict) {
  return keys(dict).reduce(
    (acc, key) => ({ ...acc, [key]: box(dict[key]) }),
    {}
  );
}
function unbox(val) {
  return isBox(val) ? val.value : val;
}

// src/runtime/literals/wide.ts
var wide = {
  boolean: false,
  string: "",
  number: 0,
  symbol: Symbol(),
  null: null,
  undefined: void 0
};

// src/runtime/lists/createConverter.ts
function createConverter(mapper2) {
  const converter = boxDictionaryValues(mapper2);
  return (input) => {
    const v = ifSameType(
      input,
      wide.string,
      (i) => converter.string.unbox(i),
      (i) => ifSameType(
        i,
        wide.number,
        (i2) => converter.number.unbox(i2),
        (i2) => ifSameType(
          i2,
          wide.boolean,
          (i3) => converter.boolean.unbox(i3),
          (i3) => ifSameType(
            i3,
            {},
            (i4) => converter.object.unbox(i4),
            (i4) => i4
          )
        )
      )
    );
    return v;
  };
}

// src/runtime/literals/ExplicitFunction.ts
function ExplicitFunction(fn) {
  return fn;
}

// src/runtime/literals/arrayToObject.ts
function arrayToObject(prop, unique) {
  const transform = (arr) => {
    const result = unique !== false ? arr.reduce((acc, v) => ({ ...acc, [v[prop]]: v }), {}) : arr.reduce((acc, v) => {
      const existing = acc[v[prop]] || [];
      return { ...acc, [v[prop]]: [...existing, v] };
    }, {});
    return result;
  };
  return transform;
}

// src/runtime/literals/defineType.ts
function defineType(literal2 = {}) {
  return (wide2 = {}) => {
    return literal2 ? { ...wide2, ...literal2 } : wide2;
  };
}

// src/runtime/literals/identity.ts
var identity = (v) => v;

// src/runtime/literals/literal.ts
function idLiteral(o) {
  return { ...o, id: o.id };
}
function nameLiteral(o) {
  return o;
}
function kindLiteral(o) {
  return o;
}
function idTypeGuard(_o) {
  return true;
}
function literal(obj) {
  return obj;
}

// src/runtime/literals/stripTrailing.ts
function stripTrailing(content, strip) {
  const re = new RegExp(`(.*)${strip}$`);
  return content.endsWith(strip) ? content.replace(re, "$1") : content;
}

// src/runtime/literals/ensureTrailing.ts
function ensureTrailing(content, ensure) {
  return content.endsWith(ensure) ? content : `${content}${ensure}`;
}

// src/runtime/literals/ensureLeading.ts
function ensureLeading(content, ensure) {
  return content.startsWith(ensure) ? content : `${ensure}${content}`;
}

// src/runtime/literals/stripLeading.ts
function stripLeading(content, strip) {
  const re = new RegExp(`^${strip}(.*)`);
  return content.startsWith(strip) ? content.replace(re, "$1") : content;
}

// src/runtime/literals/pathJoin.ts
function pathJoin(begin, ...rest) {
  const start = rest.length > 0 ? ensureTrailing(begin, "/") : begin;
  const end = rest.length > 0 ? ensureLeading(rest.slice(-1)[0], "/") : "";
  const middle = rest.length > 1 ? rest.slice(0, rest.length - 1).map((i) => stripLeading(stripTrailing(i, "/"), '"')) : [];
  const midString = stripTrailing(stripLeading(middle.join("/"), "/"), "/");
  return rest.length > 1 ? `${start}${midString}${end}` : `${start}${stripLeading(end, "/")}`;
}
export {
  Configurator,
  DEFAULT_MANY_TO_ONE_MAPPING,
  DEFAULT_ONE_TO_MANY_MAPPING,
  DEFAULT_ONE_TO_ONE_MAPPING,
  ExplicitFunction,
  FluentConfigurator,
  MapCardinality,
  and,
  api,
  arrayToKeyLookup,
  arrayToObject,
  asArray,
  box,
  boxDictionaryValues,
  condition,
  createConverter,
  createFnWithProps,
  defineProperties,
  defineType,
  dictArr,
  dictToKv,
  dictionaryTransform,
  ensureLeading,
  ensureTrailing,
  entries,
  filter,
  filterDictArray,
  fnWithProps,
  groupBy,
  idLiteral,
  idTypeGuard,
  identity,
  ifArray,
  ifArrayPartial,
  ifBoolean,
  ifDefined,
  ifFalse,
  ifNull,
  ifNumber,
  ifObject,
  ifSameType,
  ifString,
  ifTrue,
  ifUndefined,
  isArray,
  isBoolean,
  isBox,
  isFalse,
  isFunction,
  isNotFilter,
  isNull,
  isNumber,
  isNumericFilter,
  isObject,
  isString,
  isSymbol,
  isTrue,
  isType,
  isUndefined,
  keys,
  kindLiteral,
  kv,
  kvToDict,
  literal,
  mapTo,
  mapToDict,
  mapToFn,
  mapValues,
  nameLiteral,
  not,
  or,
  pathJoin,
  readonlyFnWithProps,
  ruleSet,
  strArrayToDict,
  stripTrailing,
  type,
  typeApi,
  unbox,
  wide,
  withValue
};
